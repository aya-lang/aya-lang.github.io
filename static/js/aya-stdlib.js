const AYA_STDLIB = {"std/unit.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# unit.aya\r\n.# Note: This file is currently deprecated.\r\n.#       It will be reintroduced at a later time.\r\n\r\n.{ Todo:\r\n   Make all units objects\r\n   Overload operators\r\n     \"1ft 12in +\"~ => 2ft\r\n     \"1mile 1hour /\" => 1mph\r\n     \"3hour 1mph *\" => 3mile\r\n.}\r\n\r\n:{\r\n\r\n    .# Length\r\n\r\n    0.001:mm:milimeter;\r\n    0.01:cm:centimeter;\r\n    1:m:meter;\r\n    1000:km:kilometer;\r\n    0.0254:in:inch;\r\n    0.3048:ft:feet;\r\n    0.9144:yd:yard;\r\n    1609.34:mi:mile;\r\n    1852:nmile:nauticalm;\r\n\r\n    .# Mass\r\n\r\n    0.000001:mg:milligram;\r\n    0.001:g:gram;\r\n    1:kg:kilogram;\r\n    1016.05:lton:longton;\r\n    907.185:shton:shortton;\r\n    6.35029:st:stone;\r\n    0.453592:lb:pound;\r\n    0.0283495:oz:ounce;\r\n\r\n    .# Time\r\n\r\n    1:s:second;\r\n    60:min:minute;\r\n    3600:hr:hour;\r\n    86400:day;\r\n    604800:week;\r\n    31536000:yr:year;\r\n\r\n    :1e-3:milisecond:ms;\r\n    :1e-6:microsecond;\r\n    :1e-9:nanosecond:ns;\r\n\r\n\r\n    .# Data\r\n\r\n    1:bit;\r\n    1000:kilobit:kib;\r\n    1000 kilobit *:megabit:mib;\r\n    1000 megabit *:gigabit:gib;\r\n    1000 gigabit *:terabit:tib;\r\n    8:byte;\r\n    1000 byte *:kilobyte:kb;\r\n    1000 kilobyte *:megabyte:mb;\r\n    1000 megabyte *:gigabyte:gb;\r\n    1000 gigabyte *:terabyte:tb;\r\n\r\n\r\n}:unit;\r\n\r\n\r\n.# Conversion functions (Uncomment to use)\r\n\r\n.# Type saftey version\r\n{(1 hold)({num::num from::num to::num, num from * to/})}:to;\r\n\r\n.# Regular Version\r\n.#\t{(1 hold)(\\@*\\/)}:to;\r\n\r\n:{\r\n    {(1 hold)({sub super : super_type,\r\n        super.__type__ :super_type;\r\n        super ::__type__ .- ;\r\n        sub super .+ ;\r\n        super_type super.:__type__;\r\n    })}:extends\r\n\r\n    class time\r\n\r\n    def time::__init__ {n self,\r\n        n self._to_sec self.:s;\r\n    }\r\n\r\n    def time::to_sec {self,\r\n        self.s\r\n    }\r\n\r\n    def time::__str__ {self,\r\n        self.s self._from_sec \" \" +\r\n        self :T :C +\r\n    }\r\n\r\n    def time::__repr__ (time.__str__.`)\r\n\r\n    def time::_to_sec {n self,\r\n        n self.scale_factor *\r\n    }\r\n\r\n    def time::_from_sec {n self,\r\n        n self.scale_factor /\r\n    }\r\n\r\n    def time::__add__ {a b,\r\n    }\r\n\r\n\r\n    class minute\r\n\r\n    minute extends time\r\n\r\n    def minute::scale_factor 60\r\n\r\n\r\n    class hour\r\n\r\n    hour extends time\r\n\r\n    def hour::scale_factor (60 60 *)\r\n\r\n} :time;\r\n\r\n{:time^, time.minute!}:minute;\r\n{:time^, time.hour!}:hour;\r\n\r\n","std/bitset.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# bitset.aya\n.# Defines bitset type\n\nclass bitset\n\ndef bitset::__new__ {s meta,\n    s :T ::num = {\n        :{ s:size 0sL:bits } meta :M\n    } {\n        s meta.fromlist\n    } .?\n}\n\ndef bitset::fromlist {l::list : bitset^,\n    :{ lE:size l:bits } bitset :M\n}\n\n\ndef bitset::__str__ { .bits P \"bitset!\" + }\n\ndef bitset::__repr__ (bitset.__str__.`)\n\n\n\n.#? index ::bitset.set\\n  set the bits given by the index to true\n.{ Example:\n    aya> 4 bitset! :b\n    [ 0 0 0 0 ]\n    aya> 1 b.set\n    aya> b\n    [ 0 1 0 0 ]\n    aya> [0 3] b.set\n    aya> b\n    [ 1 1 0 1 ]\n.}\ndef bitset::set {n self,\n    1 self.bits.:[n];\n}\n\n\n.#? index ::bitset.set\\n  set the bits given by the index to false\n.{ Example:\n    aya> [1 0 1 0] bitset! :b\n    [ 1 0 1 0 ]bitset!\n    aya> 0 b.reset\n    aya> b\n    [ 0 0 1 0 ]bitset!\n.}\ndef bitset::reset {n self,\n    0 self.bits.:[n];\n}\n\n.#? ::bitset.__getindex__\\n  get value of bit at the given index\n.{ Example:\n    aya> [1 0 1 0] bitset! :b\n    [ 1 0 1 0 ]bitset!\n    aya> b.[0]\n    1\n    aya> b.[0 2]\n    [ 1 1 ]\n.}\ndef bitset::__getindex__ {n self,\n    self.bits.[n]\n}\n\n\n.#? ::bitset.count\\n  return the number of true bits in the set\n.{ Example:\n    aya> [0 1 0 1] bitset! .count\n    2\n    aya> [1 1 1 1] bitset! .count\n    4\n.}\ndef bitset::count { .bits W }\n\n.#? ::bitset.__signum__\\n  not each bit\n.{ Example:\n    aya> [1 0 1 0] bitset! .!\n    [ 0 1 0 1 ]bitset!\n.}\ndef bitset::__signum__ {self,\n    self.bits #! self.M.fromlist\n}\n\n\n.#? ::bitset ::bitset.__or__\\n  or two bitsets\n.{ Example:\n    aya> [0 0 0 1] bitset! [1 1 0 0] bitset! |\n    [ 1 1 0 1 ]bitset!\n.}\ndef bitset::__or__ {other self,\n    other.bits self.bits {|}.&\n    self.M.fromlist\n}\n\n\n.#? ::bitset ::bitset.__and__\\n  and two bits\n.{ Example:\n    aya> [1 0 0 1] bitset! [1 1 0 0] bitset! &\n    [ 1 0 0 0 ]bitset!\n.}\ndef bitset::__and__ {other self,\n    other.bits self.bits {&}.&\n    self.M.fromlist\n}\n\n\n.#? ::bitset.__len__\\n  the size of the bitset\n.{ Example:\n    aya> [1 1 0 0] bitset! E\n    4\n    aya> [1 1 0 0 1 1 0 0] bitset! E\n    8\n.}\ndef bitset::__len__ { .bits E }\n","std/queue.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# queue.aya\n.# Defines the queue data structure\n\n.{? type: queue\n    A simple queue data structure\n\n    Create queues by entering a list followed by the queue constructor\n    [1 2 3] queue!\n.}\n\n\nclass queue\n\n.#? ::list ::queue.__init__\\n  convert a list into a queue\ndef queue::__init__ {l self,\n    l self.:list ;\n}\n\n\n.# str and repr overloads\ndef queue::__str__ {self,\n    self.isempty {\n        \"queue: <- -<\"\n    } {\n        \"queue: <-\" self.list P B; V; \"-<\" ++\n    } .?\n}\n\n(queue.__str__.`,0); queue.:__repr__;\n\n\n.#? ::queue.next\\n  return the next item in the queue\ndef queue::next {self,\n    self.list E 0 = {\"queue obj is empty\".D} ?\n    self.list V \\ ;\n}\n\n\n.#? ::queue.peek\\n  return the next item in the queue without removing it from the queue\ndef queue::peek {self,\n    self.list E 0 = {\"queue obj is empty\".D} ?\n    self.list 0 I\n}\n\n.#? ::queue.__len__\\n  return the number of elements in the queue\ndef queue::__len__ { .list E }\n\n\n.#? ::queue.isempty\\n  tests if the queue is empty\ndef queue::isempty { .list E 0 = }\n\n\n.#? ::any ::queue.add\\n  add an item to the queue\ndef queue::__add__ {self,\n    self.list.B ; self\n}\n\n\n.#? ::queue.clear\\n  clear the queue\ndef queue::clear {self,\n    [] self.:list\n}\n\ndef queue::__each__ {blk self,\n    self.list :# {blk}\n}\n\n","std/stack.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# stack.aya\n.# defines the stack type\n\n.{? type: stack\n    A simple stack data structure\n\n    Create stacks by entering a list followed by the stack constructor\n    [1 2 3] stack!\n.}\n\n\nclass stack\n\n.#? ::list stack!\\n  convert a list into a stack\ndef stack::__init__ {l self,\n    l self.:list;\n}\n\n\ndef stack::__str__ {self,\n    self.isempty {\n        \"stack: <- -|\"\n    } {\n        \"stack: <-\"self.listPB;V;\"-|\"++\n    } .?\n}\n\n\ndef stack::__repr__ (stack.__str__.`)\n\n\n.#? ::stack.pop\\n  return the next item in the stack\ndef stack::pop {self,\n    self.listE0= {\"stack obj is empty\" .D} ?\n    self.listV\\;\n}\n\n.#? ::stack.peek\\n  return the next item in the stack without removing it from the stack\ndef stack::peek {self,\n    self.listE0= {\"stack obj is empty\" .D} ?\n    self.list0I\n}\n\n\n.#? ::stack.len\\n  return the number of elements in the stack\ndef stack::__len__ {.listE}\n\n\n.#? ::stack.isempty\\n  tests if the stack is empty\ndef stack::isempty {.listE0=}\n\n\n.#? A ::stack.add\\n  add an item to the stack\ndef stack::push {self,\n    self.list.V; self\n}\n\ndef stack::__add__ (stack.push.`)\ndef stack::__sub__ (stack.pop.`)\n\n.#? ::stack.clear\\n  clear the queue\ndef stack::clear {self,\n    [] self.:list\n}\n\n\ndef stack::__each__ {blk self,\n    self.list :# blk.`\n}\n","std/map.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# map.aya\n.# Defines the map data structure\n\n.{? class: map\n    The map type is a key-value pair dictionary which supports any\n      and mixed data types as the key.\n.}\n\nclass map\n\ndef map::__init__ {self,\n    [] self.:keys;\n    [] self.:values;\n}\n\n\n.#? key map.haskey\\n  true if map contains key\ndef map::haskey {key self,\n    self.keys key H\n}\n\n\n.#? key value self map.put\\n  put key value pair in the map\ndef map::put {value key self : idx,\n    self.keys key N :idx;;\n    idx 0 < {\n        key self.keys .B;\n        value self.values .B;\n    } {\n        value self.values.:[idx];\n    } .?\n}\n\n\n.#? key ::map.del\\n  remove the key value pair from thist list\ndef map::del {key self,\n    .# Apply remove code only if it is in the map\n    self.keys key N $ 0 :> {\n        $@\\.-;              .# remove from keys\n        self.values\\.-;     .# remove from values\n    } {\n        ;;                  .# do nothing, clean stacke\n    } .?\n}\n\n\n.#? key map.getindex\\n  get the value for the key in the map\ndef map::__getindex__ {key self : idx,\n    self.keys key N :idx;;\n    idx 0 < {\n        \"map does not contain key $key\" .D\n    } {\n        self.values.[idx]\n    }.?\n}\n\n.#? ::block ::map.__each__\\n  apply the block to each key value pair\n.{ Example:\naya> [[1 \"one\"][2 \"two\"]] map.fromlist :m\n:{\n  [ 1 2 ]:keys;\n  [ \"one\" \"two\" ]:values;\n}\naya> m :# {k v, v.upper k m.put}\naya> m\n:{\n  [ 1 2 ]:keys;\n  [ \"ONE\" \"TWO\" ]:values;\n}\naya> m :# {k v, \"$k = $v\" :P}\n1 = ONE\n2 = TWO\n.}\ndef map::__each__ {blk self,\n    [self.keys self.values] .T :# {~ blk} ;\n}\n\n\ndef map::fromlist {list map : m,\n    map!:m;\n    list # {~ \\m.put};\n    m\n}\n","std/missing.aya":":{} :{\n  ::missing:__type__;\n  {; \"Cannot create instance of missing\" .D}:__new__;\n  {\"missing\"}:__str__:__repr__;\n  {; []}:__range__;\n\n  {;; 0}\n      :__eq__\n      :__lt__:__leq__\n      :__gt__:__geq__;\n\n  {;; missing}\n      :__add__:__radd__\n      :__sub__:__rsub__\n      :__mod__:__rmod__\n      :__and__:__rand__\n      :__or__ :__ror__\n      :__mul__:__rmul__\n      :__div__:__rdiv__\n      :__pow__:__rpow__\n      :__idiv__:__irdiv__;\n\n  {}\n      :__fact__\n      :__negate__\n      :__signnum__\n      :__sin__:__asin__\n      :__cos__:__acos__\n      :__tan__:__atan__\n      :__float__\n      :__random__\n      :__ceil__\n      :__floor__\n      :__log__\n      :__ln__\n      :__exp__\n      :__sqrt__\n      :__abs__;\n\n} :M :missing;\n","std/versionstr.aya":"class versionstr\n\ndef versionstr::__init__ {maj min pat self,\n    majP self.:major;\n    minP self.:minor;\n    pat \"\" = 0 pat .? P self.:patch;\n}\n\ndef ::v { {\n    ~ '.| 3.< ~ versionstr!\n} 0:` }\n\ndef versionstr::__str__ {self,\n    \"v\\\"$(self.major).$(self.minor).$(self.patch)\\\"\"\n}\n\ndef versionstr::__repr__ (versionstr.__str__.`)\n\n\n","std/golf.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# golf.aya\r\n.# Defines operators and variables useful for golfing\r\n\r\n.# usage: require golf *\r\n\r\n.# Import standard library\r\n:(sys.ad) \"/std\"+ :(sys.readdir) :# { \".aya\".^ S W } :# {name, \r\n    name \"golf\" =! {\r\n        \"importing $name...\":P \r\n        name __aya__.importlib.import\r\n    } ?\r\n};\r\n\r\n.# Standard library shortcuts\r\n:{\r\n    0 .M :num;\r\n    'x.M :char;\r\n    [].M :list;\r\n    \"\".M :str;\r\n\r\n    num.clip.`   num.:c;\r\n    num.digits.` num.:d;\r\n    num.round.`  num.:r;\r\n    num.bits.`   num.:b;\r\n    num.bytes.`  num.:a;\r\n\r\n    char.upper.` char.:u;\r\n    char.lower.` char.:l;\r\n\r\n    str.upper.`  str.:u;\r\n    str.lower.`  str.:l;\r\n    str.trim.`   str.:t;\r\n    str.lines.`  str.:n;\r\n\r\n    list.shuffle.` list.:q;\r\n    list.max.` list.:u;\r\n    list.min.` list.:l;\r\n    list.irange.` list.:i;\r\n}\r\n\r\nmatrix.matrix.rotate_cols.` matrix.matrix.:n;\r\nmatrix.matrix.rotate_rows.` matrix.matrix.:z;\r\n\r\n.# Single letter variables\r\n\r\n1:a;\r\n2:b;\r\n3:c;\r\n10:d;\r\n:1c:e;\r\ndataframe:f;\r\n.#:g;\r\n.#:h;\r\n.#:i;\r\n.#:j;\r\n1000:k;\r\n{[]}:l;\r\nmatrix:m;\r\n'\\n':n;\r\n.#:o;\r\n:0c :p;\r\n.#:q;\r\n{.R}:r;\r\n.#:s;\r\n.#:t;\r\n.#:u;\r\n.#:v;\r\n-1 :w;\r\n0:x;\r\n0:y;\r\n0:z;\r\n\r\n\r\n.# Single byte variables\r\n\r\n{=!} \"\\{not}\" := ;\r\n{:P} \"\\{thorn}\" := ;\r\n{:;:P} \"\\{THORN}\" := ;\r\n{2^} \"\\{sup2}\" := ;\r\n.# pop font/back shortcuts\r\n{B\\;} \"\\{iacute}\" := ;\r\n{V\\;} \"\\{igrave}\" := ;\r\n\r\n\r\n.# cdict variables\r\n:{\r\n  \"()\" :\"(\";\r\n  \"<>\" :\"<\";\r\n  \"/\\\\\":\"^\";\r\n  \"{}\" :\"{\";\r\n  \"[]\" :\"[\";\r\n\r\n  [1 2]  :\"½\";\r\n  [1 -1] :\"+\";\r\n  [-1 1] :\"-\";\r\n  [0 1]  :\".\";\r\n  [0 0]  :\"0\";\r\n  [1 1]  :\"1\";\r\n  [2 2]  :\"2\";\r\n  360    :\"3\";\r\n  128    :\"4\";\r\n  256    :\"8\";\r\n\r\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" :\"A\";\r\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" :\"B\";\r\n  \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\" :\"C\";\r\n  \"012345679\" :\"D\";\r\n  \"0123456789ABCDEF\" :\"H\";\r\n  :-7s :\"P\"; .# printable ascii\r\n  [\"QWERTYUIOP\" \"ASDFGHJKL\" \"ZXCVBNM\"] :\"Q\";\r\n  \"AEIOUaeiou\" :\"V\";\r\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\" :\"W\";\r\n\r\n} \r\n.# assign to global __cdict__ variable\r\n:G.[0].:__cdict__;\r\n","std/io.aya":"class path\n\n.# Create a new path (accepts relative or abs paths)\n.# Custom constructor\n{dir meta : absolute_path(0),\n    .# Already a path?\n    dir:T ::path = {\n        dir\n    } {\n        .# Input is a string?\n        dir:T ::str = {\n            .# If direct path\n            dir meta._isabs ! {\n                0 :absolute_path;\n            } {\n                1 :absolute_path;\n            } .?\n            :{\n                dir meta._split :dirs;\n                absolute_path :is_absolute_path;\n            } meta :M\n        } {\n            \"Cannot create path from $dir\" .D\n        } .?\n    } .?\n} path.:__new__;\n\n\n.# ::path.isfile\\n  Return true if path is file (last item in the path contains a \".\")\ndef path::isfile {self,\n    self.dirs.[-1] \".\" H\n}\n\n\n.#? ::str ::path.add\\n  append file or dir to path, if path is file, don't change\ndef path::__add__ {dir::str self,\n    .# Can only join if the path is not a file\n    self.isfile ! { : newpath ,\n        .# Make a copy of this path\n        self $ :newpath; ;\n        newpath.dirs dir path._split J\n        path._clean newpath.:dirs;\n        newpath\n    } {\n        self\n    }.?\n}\n\ndef path::__radd__ {\\.__add__}\n\n\n.# String representation of the path\ndef path::__str__ {self,\n    self.dirs \"/\" %\n    self.is_absolute_path self._iswindows ! & {\n        \"/\" \\ +\n    } ?\n    .#self.dirs :9s % self.M.root :9s + \\+\n    .#self.isfile ! {:9s +} ?\n}\n\n(path.__str__.`,0); path.:__repr__;\n\n\n.#? ::path.dec\\n  Go up a directory\ndef path::__dec__ {self,\n    self.dirs B;; self\n}\n\n.#? ::str path.readdir\\n  list of file/dir names in the given path\ndef path::readdir {path,\n    P :(sys.readdir)\n}\n\n.#? path.working\\n  working directory\ndef path::working {path,\n    :(sys.wd) path!\n}\n\n.#? path.aya\\n  aya directory\ndef path::aya {path,\n    :(sys.ad) path!\n}\n\ndef path::clean {self,\n    self.dirs self._clean self.:dirs;\n}\n\n\n.#\n.# Private helper methods\n.#\n\n\n.# ::str path.split\\n  split a string using the system file sepatator and remove empty dir names\ndef path::_split {dir::str path,\n    dir '\\\\' S #{'/ S ~}\n    .# Remove empties\n    [\"\"] :|\n}\n\n.# dirs::list path._fixhome\n.# If the path list contains a \"~\"\n.#   find the last \"~\" and take all directories after it\ndef path::_fixhome {dirs::list path,\n    dirs U \"~\" N    .# Reverse and find the first ~ (aka the last ~)\n\n    .# Does the path contain a \"~\" ?\n    $ 0 :> {\n        .< U .# Take all directories before the \"~\" and reverse\n\n        .# Append the home dir to the front\n        path.home.dirs $\\;  .# Copy home.dirs\n        \\ :J                .# Append to front\n    } {\n        ;U .# Pop the -1 and put the list back\n    } .?\n}\n\n.# ::str path._isabs\\n  return true of the given string is an absolute path\ndef path::_isabs {p::str path,\n\tpath._iswindows {\n\t\tp 1 I ': =\n\t} {\n\t\tp \"/\" N0=\\;\n\t} .?\n}\n\n.# Remove all \"..\" by traversing the directories\ndef path::_clean {dirs::list path : i(0),\n    .# Remove root and self refs (\".\")\n    dirs [path.root \".\"] :| :dirs;\n\n    .# If there is a \"..\" remove the dir before it\n    {{\n        .# If there is a \"..\",\n        dirs.[iB] \"..\" = {\n            .# Remove the \"..\" and the dir before it\n            dirs [i iB] .-;\n            .# Then move the index back 2\n            i2-:i;\n        } ?\n        ::iB\n        i dirs EV <\n    }W}\n    .# If the above code has an error, the path is invalid\n    {; []:dirs;} .K\n    dirs\n}\n\ndef path::_iswindows {self,\n\t:9s \"\\\\\" =\n}\n\n\n\n.#\n.# Constants\n.#\n\n.#? path.root\\n  root dir name\n\"user.dir\" :(sys.getprop) :9s .^ S .[0] path.:root;\n\n\n\n\"~\" :(sys.resolvehome) path! path.:home;\n\n:{ :(sys.wd) path._split :dirs} path :M path.:dfltworking;\n\n\n\n.####################\n.# FILE             #\n.####################\n\nclass file\n\ndef file::__init__ {filepath type::char  self : path^,\n    .# save a copy of the path\n    filepath path!      self.:path ;\n    .# open the stream\n    self.path P type :(fstream.O) self.:id ;\n}\n\n.#? ::file.close\\n  close a file. return 1 is success\ndef file::close {self,\n    self.flush;\n    self.id 'c :(fstream.O)\n}\n\n.#? ::file.isopen\\n  test if a file stream is open\ndef file::isopen {self,\n    self.id 'i :(fstream.O) 0 =!\n}\n\n.#? ::file.isread\\n  return 1 if file is an input stream\ndef file::isinput {self,\n    self.id 'i :(fstream.O) 1 =\n}\n\n.#? ::file.iswrite\\n  return 1 if file is an output stream\ndef file::isoutput {self,\n    self.id 'i :(fstream.O) 2 =\n}\n\n.#? ::file.print\\n  print to a file if it is an input stream\ndef file::print {s self,\n    sP self.id :(fstream.O)\n}\n\n.#? ::file.println\\n  print string followed by a newline tp a file\ndef file::println {s self,\n    sP \"\\n\" + self.id :(fstream.O)\n}\n\n.#? ::file.readchar\\n  read the next char in the file, return -1 if EOF or invalid stream\ndef file::readchar {self,\n    self.id 'b :(fstream.O)\n}\n\n.#? ::file.readline\\n  read the next line in the file, return 0 is EOF or invalid stream\ndef file::readline {self,\n    self.id 'l :(fstream.O)\n}\n\n.#? ::file.readall\\n  read all text in the stream, return \"\" if EOF and 0 if invalid stream\ndef file::readall {self,\n    self.id 'a :(fstream.O)\n}\n\n.#? ::file.lines\\n  return a list containing the lines in the file\ndef file::lines {self,\n    self.id 'a :(fstream.O) '\\n' S\n}\n\n.#? ::file.flush\\n  flush an output stream\ndef file::flush {self,\n    self.id 'f :(fstream.O)\n}\n\ndef file::__repr__ {self,\n    [\n        self.isopen\n            {\"<stream(\" self.isinput {\"R\"} {\"W\"} .? \"):\"}\n            \"<closed:\"\n        .?\n        self.path P \">\"\n    ]W\n}\n\n\n.{ Example:\n\n    \"file.txt\" 'r file!.do {f,\n        f.readll :P\n    }\n.}\ndef file::do {self,\n    {:self^, ~ self._do} 0 :`\n}\n\n.# Helper function for file.do\ndef file::_do {blk__::block self__,\n    {\n        self__ blk__\n    } {e,\n        self__.close;\n        e .D .# re-throw\n    } .K\n    self__.close;\n}\n\n.#? stdin::file\\n  standard input stream\n:{\n    1:id;\n\n    .# Overloads\n    1:isopen;\n    0:close;\n    1:isread;\n    0:iswrite;\n    \"stdin\":path;\n} file :M :stdin;\n\n.#? stdout::file\\n  standard output stream\n:{\n    2:id;\n\n    .# Overloads\n    1:isopen;\n    0:close;\n    1:iswrite;\n    0:isread;\n    \"stdout\":path;\n} file :M :stdout;\n\n\n\n.# dummyfile for testing opening and closing of input streams\n\nclass dummyfile\n\ndef dummyfile::__init__ {name self,\n    \"opened dummy file '$name'\" :P\n    name self.:name;\n}\n\ndef dummyfile::__repr__ {self,\n    \"<dummyfile: $(self.name)>\"\n}\n\ndef dummyfile::close {self,\n    \"closed dummy file '$(self.name)'\" :P\n}\n\ndummyfile file.:dummyfile ;\n\n\n:{\n    {path, .# ::path or ::str\n        path P :(fileutils.readallbytes)\n    }:readallbytes;\n\n}:fileutils;\n","base/str.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# string.aya\n.# Defines functions for working with strings and regular expressions\n\n:{\n    .# Import list variables\n    [].M W\n\n\n    {\"\\\\s+\" S E0=}:iswhitespace;\n\n    .#? ::str.trim\\n  remove whitespace from start and end of string\n    {\n        :& .iswhitespace {\n            ; \"\"\n        } {\n            \"^\\\\s+\" S B\\; \"\\\\s+$\" S V\\; \n        } .?\n    }:trim;\n\n\n    .#? ::num ::char ::str .leftpad\\n  left pad string S so it is at least length I using char C\n    {len::num pad::char s,\n        s.E len\\- {pad\\:J}\\O\n    }:lpad;\n\n\n    .#? ICS.rightpad\\n  right pad string S so it is at least length I using char C\n    {len::num pad::char s,\n        s.E len\\- {pad:J}\\O\n    }:rpad;\n\n\n    .# S.tolower\\n  convert string to uppercase\n    {:#{.upper}}:upper;\n\n\n    .# S.toupper\\n  convert string to lowercase\n    {:#{.lower}}:lower;\n\n\n    .#? S.isnum\\n  returns true if the string is a valid number\n    {.! :T ::num =}:isnum;\n\n\n    .#? S.titlecase\\n  convert a string to titlecase\n    {s,\n        s ERB; # {i,\n            s.[iV] .iswhitespace {\n                s.[i].upper s.:[i];\n            } ?\n        };\n        s.[0].upper s.:[0];\n        s\n    }:titlecase;\n\n\n    .#? S.lines\\n  split a string into lines. ignore traling newlines\n    {\"\\n\"S}:lines;\n\n\n    .#? S.bytes\\n  convert string to byte list\n    {:'}:bytes;\n\n\n    .#? S.parsenum\\n  If num, return num, else return str (rm surrounding quotes)\n    {\n        .!\n        $:T ::str = {\n            .# If it is a string, test if it has quotes and remove them\n            .trim $ [0 -1]I \"\\\"\\\"\" = {B;V;} ?\n        } ?\n    }:parsenum;\n\n\n    .#? sep S.readdlm\\n  convert a csv string into a 2d list\n    {sep s,\n        sepP:sep;\n        s.lines :# {\n            sep S :# {.parsenum}\n        }\n        .makesquare\n    }:readdlm;\n\n\n    .#? ::str ::str .endswith\\n  test if a string 1 ends with string 2\n    {:&E@\\.>=}:endswith;\n\n    .#? ::str .rmquote\\n  remove single leading/trailing quote characters if they exist\n    .# aya> \"A\".rmquote\n    .# \"A\"\n    .# aya> \"\\\"A\\\"\".rmquote\n    .# \"A\"\n    .# aya> \"\\\"A\\\"b\".rmquote\n    .# \"\"A\"b\"\n    {s,\n        {\n            (s E 2 <) {\n                s\n            } (s.[-1] '\" = s.[0] '\" = &) {\n                s $ \\ ; B ; V ;\n            } {\n                s\n            }\n        } :?\n    }:rmquote;\n\n}\n\n\n.# Merge with str metatable\n\"\" .M \\.+\n\n\n","std/enum.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Defines the enum keyword which allows for\n.#  easy creation of enum classes and symbol groups\n\n{class::sym enums::list : dict meta,\n\n    .# The metatable for each enum member\n    :{\n        class :__type__;\n        1 :__pushself__;\n        {self, \"$(self.__type__:C).$(self.name:C)\"}:__str__:__repr__;\n        {other self,\n            other.__type__ self.__type__ =\n            other.name self.name = &\n        }:__eq__;\n    }:meta;\n\n    .# The enum dict\n    :{ class:name }:dict;\n\n    .# Add each element to the enum dict\n    enums # {e,\n        :{e:name} meta :M e dict :D ;\n    };\n\n    .# Create and add the metatable for the enum\n    dict :{\n        1 :__pushself__;\n        ::enum :__type__;\n        {.name:C}:__repr__:__str__;\n    } :M\n\n    .# Assign the name of the enum to the enum class\n    class := ;\n}:_enum_impl;\n\n\n.# enum macro\n\n{ : _enum_impl(_enum_impl.`),\n    { : _enum_impl^ , :&.[0]:S~ \\.[1]~.*:#{:S~} _enum_impl } 2 :`\n}:enum;\n","std/asciiart.aya":".{\n    asciiart\n\n    A small toy library for drawing ascii art\n\n    asciiart makes heavy use of operator overloading to allow programs\n    to be as short and concise as possible.\n\n    Examples:\n\n      - A simple train:\n\n        aya> \" 6_`|6 |` ()--()\"_ 3L\"  ~\"_T*\n        asciiart:\n         ______   ______   ______\n        |      | |      | |      |\n         ()--() ~ ()--() ~ ()--()\n\n\n      - Order N Serpinski triangle:\n\n        aya> 3 \"##`#\"_\\L{I}/\n        asciiart:\n        ########\n        # # # #\n        ##  ##\n        #   #\n        ####\n        # #\n        ##\n        #\n\nhttps://codegolf.stackexchange.com/questions/101684/all-aboard-the-ascii-train\n\"hello\"\n({\n.E\"3 3_`  | # |`  |3_|`_|5\\\"|\"_ \"\\\"`-0-0-'\"/\\L\\{'#\\JI}.&W\"4 o O O`3 o`  TW__[O]` {6=|\" _\"./o--000'\"/\\+\n})\n.}\n\nclass asciiart\n\n.# alias\nasciiart:aa;\n\ndef asciiart::__init__ {str self,\n    str :T ::str = {\n        [str] self.:list ;\n    } {\n        .# list\n        .# Make sure all are at least as long as the longest\n        str :&#E .max #.< :str ;\n        str self.:list ;\n    } .?\n}\n\ndef asciiart::__eq__ {self c::char,\n    self.list :# { :# {; c}} self.M!\n}\n\ndef asciiart::__str__ {self,\n    self.list \"\\n\" %\n}\n\ndef asciiart::__repr__ {self,\n    \"asciiart:\\n$(self.__str__)\\n\"\n}\n\n\ndef asciiart::__negate__ {self,\n    self.list.T self.M!\n}\n\n\n.{  Transpose\n    Example:\n\n    aya> \"3#`.##`..#\"_ $ T\n    asciiart:\n    ###\n    .##\n    ..#\n     asciiart:\n    #..\n    ##.\n    ###\n.}\ndef asciiart::__negate__ {self,\n    self.list.T self.M!\n}\n\n\n.{ Example:\n\n    aya> \"3#`3.`#..\"_ $ +\n    asciiart:\n    ######\n    ......\n    #..#..\n\n    aya> \"3#`3.`#..\"_ '~ +\n    asciiart:\n    ###~\n    ...~\n    #..~\n\n    aya> \"3#`3.`#..\"_ \")>\" +\n    asciiart:\n    ###)>\n    ...)>\n    #..)>\n\n    aya> [\"3#`3.`#..\"_ $ '~\\] W\n    asciiart:\n    ###~###\n    ...~...\n    #..~#..\n.}\ndef asciiart::__add__ {other self,\n    other :T ::char = other :T ::str = | {\n        self.list #{other \\+} self.M!\n    } {\n        other.list .T self.list.T :J .T self.M!\n    } .?\n}\n\n\ndef asciiart::__radd__ {self other,\n    self.list #{other +} self.M!\n}\n\n\ndef asciiart::w {self,\n    self.list.T E\n}\n\ndef asciiart::h {self,\n    self.list E\n}\n\n.{ Horizontal stack\n   Example:\n    aya> \"3#`3.`#..\"_ $ /\n    asciiart:\n    ###\n    ...\n    #..\n    ###\n    ...\n    #..\n.}\ndef asciiart::__div__ {other self,\n    other.list $\\; self.list $\\; :J self.M!\n}\n\ndef asciiart::__rdiv__ {self other,\n    self other self.M! /\n}\n\n\n.{ Reverse along vertical axis\n   Example:\n    aya> \"3#`3.`#..\"_ $ U\n    asciiart:\n    ###\n    ...\n    #..\n     asciiart:\n    ###\n    ...\n    ..#\n.}\ndef asciiart::__reverse__ {self$,\n    self.list :#{U};\n    self\n}\n\ndef asciiart::__dec__ {self$,\n    self.list U ;\n    self\n}\n\ndef asciiart::join {list self,\n    list :#{self} B; W\n}\n\ndef asciiart::__rpow__ {self num,\n    self {self +} numV %\n}\n\n.{ Example:\n    aya>  \"aba`bad\" _ '# I\n    ::char\n    asciiart:\n    ###\n    ###\n\n    aya>  \"aba`bad\" _ \"a#\" I\n    ::str\n    asciiart:\n    #b#\n    b#d\n\n    aya> \"# ` #\"_ \"abc`def\"_ I\n    asciiart:\n    abc\n    def\n       abc\n       def\n.}\ndef asciiart::__getindex__ {index self,\n    {\n        (index :T ::str =) {\n            index self.replace\n        } (index :T ::char =) {\n            index self.fill\n        } (index :T ::asciiart =) {\n            index self.replace_aa\n        } {\n            \"asciiart::__getindex__ invalid index type\" .D\n        }\n    } :?\n}\n\n.{ Example:\n    aya> '@ \"abc`def\" _ .fill\n    asciiart:\n    @@@\n    @@@\n\n    aya> \"#\" \"abc`def\" _ .fill\n    asciiart:\n    ###\n    ###\n.}\n\ndef asciiart::fill {c self,\n    c :T ::str = {c.[0] :c;} ?\n    self.list :# { :# {; c}} self.M!\n}\n\n\n.{ Example:\n    aya> \"#-\" \"###`# ` # \"_ .replace\n    asciiart:\n    ---\n    -\n     -\n\n    aya> \"###`***\" \"###`# ` # \"_ .replace\n    asciiart:\n    ***\n    #\n     #\n.}\ndef asciiart::replace {s::str self,\n    s '` S .E1={~}? :s ;\n    s V:from ; V:to ; ;\n    self.list :# {from to .&}\n    self.M!\n}\n\n.{ Example:\n    aya> \"3#`# #`3#\"_\n    asciiart:\n    ###\n    # #\n    ###\n\n    aya> \"3#`# #`3#\"_ $.replace_aa\n    asciiart:\n    #########\n    # ## ## #\n    #########\n    ###   ###\n    # #   # #\n    ###   ###\n    #########\n    # ## ## #\n    #########\n.}\ndef asciiart::replace_aa {a::asciiart self : l,\n    a $ ' I \\ J :l;    .# List of aa and empty version of aa\n    self.list ' #.= #! .# Mask of filled/empty\n    :#{\n        :#{ l \\ I }    .# Use the mask to index into the list\n        W              .# Concat each aa in the row\n    } {/}/             .# Concat each row\n}\n\ndef asciiart::rle {s asciiart,\n    s $ \"\\\\d+\" S \\ \"\\\\d+\" &  .# Split into lists of string sections and runs\n                            .# Ex: \"3a 4b\" => [\"\" \"a \" \"b\"] [\"3\" \"4\"]\n    .E 0 = {\n        ;;s                 .# If no rle to do, just return the string\n    } {                     .# There is rle to do, do this block\n        #.!                 .# convert strings to nums => [3 4]\n        \\V@@                .# Remove the leading string and rearrange\n        {\n            V               .# pop the charachter to repeat\n            @L              .# repeat the character\n            \\+              .# join with original string\n        }\n        .&                  .# Apply the above block to each pair in the list\n        W+                  .# Combine everything\n    } .?\n}\n\n\n.# Sample letters for testing\n[ \"00000\" \"0   0\" \"00000\" ] asciiart!T :o;\n[ \"EEEEE\" \"E E E\" \"E   E\" ] asciiart!T :e;\n[ \"T    \" \"TTTTT\" \"T    \" ] asciiart!T :t;\n[ \"GGGGG\" \"G G G\" \"G GGG\" ] asciiart!T :g;\n\n\n{:asciiart^, asciiart.rle '` S asciiart!}:_;\n\n.{ Example:\n    Generate a Sierpinski carpet:\n    \"3#`# #`3#\"_$I$I\n    .. or triangle\n    \"##` #\"_ $I$I\n\n    \".:.` .\"_$I$I\n\n    \"##`#\"_$I $U\\+ $V\\/ $I\n.}\n","base/test.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# test.aya\n.# Defines an interface for testing aya code\n\n:{ } :test;\n\n.# New simpler test function\n{blk,\n.{\n    {\n        blk :!\n    } {ex,\n        ex.` :T ::dict = {\n            ex ::type 0 .I ::assert_err = {\n                [\"Test Failed: $blk\"\n                 \"\\tExpected: $(ex.expected.`)\"\n                 \"\\tReceived: $(ex.received.`)\"] \"\\n\"* :P\n            } {\n                ex .D\n            } .?\n        } {\n            ex .D\n        } .?\n    } .K\n\n.}\n    blk :!\n} test.:test;\n","std/turtle.aya":"require canvas {canvas}\r\nrequire color {color colors}\r\n\r\n.# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.{\r\n    turtle\r\n\r\n    A simple turtle graphics library\r\n    The API is modeled after python's built-in turtle library\r\n\r\n    Examples:\r\n        .# Offset nested balls\r\n        :{ 200:width 200:height} turtle!:t\r\n        10R :# {n, {0.1 t.right n t.fd 2:Z} 100 %} ;\r\n\r\n        .# A small colorful star\r\n        color.colors.red {10\\.hueshift $ t.pencolor 40 t.fd 124 t.right} 36 %\r\n.}\r\n\r\n\r\ncolors.white :c_white;\r\ncolors.black :c_black;\r\n\r\nclass turtle\r\n\r\ndef turtle::__init__ {params::dict self : canvas^ c_black^ c_white^,\r\n\r\n    .# Default values\r\n    :{\r\n        0:x\r\n        0:y\r\n        0:r\r\n        400:width;\r\n        300:height;\r\n        ::deg:units;\r\n        1 :autodraw;\r\n        c_white :bg_color;\r\n        c_black :fg_color;\r\n        nil :canvas;\r\n    }\r\n\r\n    .# Merge user defined\r\n    params .+ :params;\r\n\r\n    params.x self.:_x;\r\n    params.y self.:_y;\r\n    params.r self.:_r;\r\n\r\n    params.units [::deg ::degrees].in self.:_use_deg;\r\n\r\n    .# Use the provided canvas or generate one?\r\n    params.canvas nil = {\r\n        params.width self.:_w;\r\n        params.height self.:_h;\r\n        :{ self._w:width self._h:height \"Turtle\":name } canvas! self.:_cvs;\r\n    } {\r\n        params.canvas self.:_cvs;\r\n        self._cvs.width self.:_w;\r\n        self._cvs.height self.:_h;\r\n    } .?\r\n\r\n    .# Draw background\r\n    params.bg_color self._cvs.set_color\r\n    0 0 self._cvs.width self._cvs.height self._cvs.fillrect\r\n\r\n    params.fg_color self._cvs.set_color\r\n\r\n\r\n    1 self.:_pen_down;\r\n    params.autodraw self.:_autodraw;\r\n\r\n\r\n}\r\n\r\ndef turtle::__repr__ {self,\r\n    \"turtle: pos=($(self._x), $(self._y)) dir=$(self._r)\"\r\n}\r\n\r\n.#################\r\n.# Turtle Motion #\r\n.#################\r\n\r\ndef turtle::fd {n self : px py,\r\n    self._x :px;\r\n    self._y :py;\r\n    self._x self._r Mc n * + self.:_x;\r\n    self._y self._r Ms n * + self.:_y;\r\n    px py self._step_from\r\n}\r\n\r\ndef turtle::right {amount self,\r\n    self._r amount self._to_rad + self.:_r;\r\n}\r\n\r\ndef turtle::left {amount self,\r\n    self._r amount self._to_rad - self.:_r;\r\n}\r\n\r\ndef turtle::goto {x y self : px py,\r\n    self._x :px;\r\n    self._y :py;\r\n    x self.:_x;\r\n    y self.:_y;\r\n    px py self._step_from\r\n}\r\n\r\ndef turtle::pos {self,\r\n    self._x self._y\r\n}\r\n\r\ndef turtle::draw {self,\r\n    self._cvs.show\r\n}\r\n\r\ndef turtle::close {self,\r\n    self._cvs.close\r\n}\r\n\r\n.###############\r\n.# Pen Control #\r\n.###############\r\n\r\ndef turtle::pendown {self,\r\n    1 self.:_pen_down;\r\n}\r\n\r\ndef turtle::penup {self,\r\n    0 self.:_pen_down;\r\n}\r\n\r\ndef turtle::isdown {self,\r\n    self._pen_down\r\n}\r\n\r\ndef turtle::pencolor {c::color self,\r\n    c self._cvs.set_color\r\n}\r\n\r\n\r\n.####################\r\n.# Helper Functions #\r\n.####################\r\n\r\n\r\n.# This function maps the turtle\r\n.# coordinate space to the canvas coordinate space\r\n.# The turtle lives in a coordinate frame where (0,0) is\r\n.# at the center of the canvas.\r\ndef turtle::_tf {x y self,\r\n    x self._w 2/ +\r\n    y self._h 2/ +\r\n}\r\n\r\n.# Convert the input value to radians if units is degrees\r\ndef turtle::_to_rad {val self,\r\n    self._use_deg\r\n        val :1p1 180 / *\r\n        val\r\n    .?\r\n}\r\n\r\n\r\n.# Callback function for after the turtle steps\r\n.# Assumes the turtle's position has already been updated\r\n.# px and py are the turtles previous location\r\ndef turtle::_step_from {px py self,\r\n    self._pen_down {\r\n        px py self._tf\r\n        self._x self._y self._tf\r\n        self._cvs.line\r\n        self._autodraw {\r\n            self._cvs.show\r\n        } ?\r\n    } ?\r\n}\r\n\r\n.#############\r\n.# Overloads #\r\n.#############\r\n\r\ndef turtle::__rpow__ {self val,\r\n  val self.fd\r\n  self\r\n}\r\n\r\n\r\n.# For testing\r\n:{\r\n    100 :width\r\n    100 :height\r\n    ::deg :units\r\n} turtle! :t\r\n","base/interpreter.aya":".# Defines \\t interpreter flag\n\n{\n    .# Create a block from the input and time the execution\n    .~ .time\n    .# Print the results of the block\n    .AB\\ #{.P\" \".P}; \"\":P\n    .# Print execution time message\n    \"Execution took \"\\+\" ms\"+:P\n\n} __aya__.interpreter.:t\n","std/color.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# colors.aya\r\n.# Defines both color and colors types\r\n\r\n.{? class: color\r\n    A module for manipulating and printing colors in Aya\r\n.}\r\nclass color\r\n\r\n.#\r\n.# Constructors\r\n.#\r\n\r\ndef color::__init__ {r::num g::num b::num self,\r\n    [[r g b], .round 0 255 .clip] ~\r\n    self .:b .:g .:r ;\r\n    1.0 self.:a;\r\n}\r\n\r\n\r\ndef color::newhex { color ,\r\n    0 dot_i '#= {V;} ? .# Strip leading '# if it exists\r\n    16 2 .& 24 .> [3 8] L #{2 10 .&} ~ color!\r\n}\r\n\r\n\r\ndef color::newhsv { color,\r\n    color.hsvtorgb~ color!\r\n}\r\n\r\ndef color::fromstr { s::str color,\r\n    s :(color.fromstr) color.fromdict\r\n}\r\n\r\ndef color::fromdict { d::dict color ,\r\n    d.r d.g d.b color!\r\n}\r\n\r\n\r\n.#\r\n.# Overloads\r\n.#\r\n\r\ndef color::__repr__ {self,\r\n    \"($(self.r) $(self.g) $(self.b)) color!\"\r\n}\r\n\r\n\r\ndef color::__str__ {self,\r\n    \"($(self.r) $(self.g) $(self.b)) color!\"\r\n}\r\n\r\n\r\n.#\r\n.# Math\r\n.#\r\n\r\n.#? ::color ::color *\\n  multiply two colors\r\ndef color::__mul__ {other self\r\n    other.rgbf self.rgbf * 255* ~ self.M!\r\n}\r\n\r\n\r\n.# ::color N *\\n  multiply a color by a value\r\ndef color::__rmul__ {self n,\r\n    self.rgbf n * 255* :#{0 255 .clip} ~ self.M!\r\n}\r\n\r\n\r\n.#\r\n.# Conversions\r\n.#\r\n\r\n.#? ::color.rgbf\\n  return a list of RGB values represented as floats from 0.0 to 1.0\r\ndef color::rgbf {self, [self.r self.g self.b] 255 / }\r\n\r\n\r\n.#? ::color.rgb\\n  return a list containing red, green, and blue values respectively\r\ndef color::rgb {self, [self.r self.g self.b]}\r\n\r\n\r\n.#? ::color.hex\\n  return a hexadecimal string representation of the color\r\ndef color::hex {.rgb #{10 16 .& 2 '0 @.lpad}W}\r\n\r\n\r\n.#? ::color.hsv\\n  return a list containing hue, sat, and val respectively\r\ndef color::hsv {self, self.rgb255/~ self.M.rgbtohsv}\r\n\r\n\r\n.#\r\n.# Interpolation\r\n.#\r\n\r\n.#? ::num ::color ::color.grad\\n  creates a gradient of rgb lists from color1 to color2\r\ndef color::grad {n::num begin::color self,\r\n    [ [begin.rgb self.rgb, [2| n] .R .\\]~, self.M!]\r\n}\r\n\r\n.#? ::color ::color color.mid\\n  returns the color in between color1 and color2 using rgb\r\ndef color::mid {3@@\\.grad 1I}\r\n\r\n\r\n.#? [::color] N color.multigrad\\n  compute a linear gradient with resolution N between each color\r\ndef color::multigrad {l n,\r\n    [l {a b, n a b .grad B} / ; ].F\r\n}\r\n\r\n.#? N ::color.hueshift\\n  shift hue by N degrees\r\ndef color::hueshift {n self,\r\n    self.hsv $\\; V n + 360 :% \\J ~ self.M.newhsv\r\n}\r\n\r\n\r\n.#\r\n.# Static conversion utilities\r\n.#\r\n\r\n.#? NNN color.hsvtorgb\\n  convert h s v (0-360,0-1,0-1) color to hsv\r\ndef color::hsvtorgb {h s v color : hi p q t ff,\r\n    .# no saturation, just greyscale\r\n    s 0 = {\r\n        [v v v]\r\n    } {\r\n        .# Compute hue index\r\n        .# floor -> mod 360 -> /60 (hh) -> floor (hi)\r\n        h 360 :% 60 /:hh;\r\n        hh .\\ :hi;\r\n\r\n        hh hi - :ff; .# fractional part\r\n\r\n        v 1 s - * :p;\r\n        v 1 s ff * - * :q;\r\n        v 1 s 1 ff - * - * :t;\r\n\r\n        [\r\n            [v t p]\r\n            [q v p]\r\n            [p v t]\r\n            [p q v]\r\n            [t p v]\r\n            [v p q]\r\n        ] hi I\r\n    } .?\r\n\r\n    255* :#{.round}\r\n}\r\n\r\n\r\n.#? NNN color.rgbtohsv\\n  convert r g b color to hsv\\n  r,g,b values are from 0 to 1\r\ndef color::rgbtohsv {r g b color : h s v delta maxv minv,\r\n    [r g b].min:minv;\r\n    [r g b].max:maxv;\r\n    maxv:v;\r\n    maxv minv-:delta;\r\n\r\n    maxv 0 =! {\r\n        r maxv = {\r\n            g b- delta/\r\n        } {\r\n            g maxv = {\r\n                b r- delta/ 2+\r\n            } {\r\n                r g- delta/ 4+\r\n            } .?\r\n        } .? 60* :h;\r\n\r\n        h 0< {h 360+:h;} ?\r\n\r\n        delta maxv/:s;\r\n    } {\r\n        0:s;\r\n        -1:h;\r\n    } .?\r\n    [h s v]\r\n}\r\n\r\n\r\n.{? module: colors\r\n    The colors module defines several color objects. For example:\r\n      colors.red\r\n      colors.aqua\r\n      colors.raspberry\r\n.}\r\n:{} :colors;\r\n\r\n:{\r\n    :(color.name_list) :# {color_name : color_dict,\r\n        color_name :(color.fromstr) :color_dict;\r\n        color_dict.r color_dict.g color_dict.b color! color_name :=\r\n    }\r\n}:named_colors;\r\n\r\n.# Add all named colors to the colors module\r\ncolors named_colors .+\r\n\r\n72  72  68  color! colors.:fg;    .# Aya GUI foreground color\r\n39  40  34  color! colors.:bg;    .# Aya GUI background color\r\n\r\ndef colors::Q {\r\n    ;255Q 255Q 255Q color!\r\n}\r\n\r\n.# Add the colors module as a submodule of color\r\ndef color::colors colors\r\n","std/random.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Functions related to random number generation\n\n.#? ::list ::num random.lotto\\n  pick N random items from L\ndef ::lotto {\n    \\.EV@L#QI\n}\n\n.#? lo::num hi::num random.randint\\n  random integer between lo and hi\ndef ::randint {\n    \\$@\\-Q+\n}\n\n.# Generate a normally distributed random number using the Box-Muller transform\ndef ::norm {\n    .Q Ml -2 * .^ :2p .Q * Mc *\n}\n","std/threading.aya":"struct thread {id}\n\ndef ::new {: thread^,\n    :(thread.new) thread!\n}\n\n.# Create a new thread\ndef thread::new {cls,\n    :(thread.new) thread!\n}\n\n\ndef thread::add_task {block self,\n    .# Add task to thread\n    .#\n    .# aya> {1 1 +} thread.add_task\n    .# aya> {1 1 +} thread +\n\n    block.` self.id :(thread.add_task)\n    self\n}\n\n.# Use sum to easily add multiple tasks to a thread\n.# aya> threading.new :t;\n.# aya> [{1} {2} {3}]: tasks;\n.# t tasks J W\ndef thread::__add__ (thread.add_task.`)\ndef thread::__radd__ {\\+}\n\n\n\ndef thread::wait_for_result {self,\n    .# Join and get result from thread\n    .#\n    .# aya> thread.wait_for_result\n    .# aya> thread .|\n    self.id :(thread.wait_for_result)\n}\n\ndef thread::__abs__ (thread.wait_for_result.`)\n\n\ndef thread::has_unfinished_tasks {self,\n    self.id :(thread.has_unfinished_tasks)\n}\n\n\n\nclass pool\n\ndef pool::__init__ {n_threads::num self : thread^,\n    [] self.:threads_with_tasks;\n    [n_threads,; thread.new] self.:thread_pool;\n}\n\ndef pool::exec { tasks::list finished_callback::block self : finished_threads,\n    .# Loop until no tasks remain\n    {\n        .# For each thread with a task, check if it is ready,\n        .# if it is, get the result and add it back to the pool\n        [] :finished_threads;\n        self.threads_with_tasks :# {thread : res,\n            thread.has_unfinished_tasks ! {\n                thread.wait_for_result finished_callback\n                .#draw_result cvs.show\n                thread finished_threads .B;\n            } ?\n        };\n\n        .# Remove finished threads from threads with tasks\n        self.threads_with_tasks finished_threads :| self.:threads_with_tasks;\n\n        .# Add the finished threads back to the pool\n        self.thread_pool finished_threads J self.:thread_pool;\n\n       .# Add a task to each thread in the pool\n        self.thread_pool :# {thread,\n            tasks E 0 > {\n                tasks B\\; thread.add_task\n                thread self.threads_with_tasks .B;\n            } ?\n        };\n\n        .# Remove threads with tasks from the pool\n        self.thread_pool self.threads_with_tasks :| self.:thread_pool;\n\n        1 :Z\n\n    tasks E 0 > } W\n\n    .# Wait for all remaining tasks\n    self.threads_with_tasks :# {thread : res,\n        thread.wait_for_result finished_callback\n    };\n\n    .# Put everything back in the pool\n    self.threads_with_tasks self.thread_pool J self.:thread_pool;\n    [] self.:threads_with_tasks;\n}\n\n\n\n","std/math.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# math.aya\r\n.# Essential math functions for Aya\r\n\r\n.#############\r\n.# Constants #\r\n.#############\r\n\r\n\r\n:1c :e;    .#? euler: euler's constant e\r\n:0c :pi;       .#? pi:  constant \\{pi}\r\n:4c :nan;      .#? nan:  not a number double literal\r\n:5c :inf;      .#? inf:  infinity double literal\r\n:6c :minf;     .#? minf:  minus infinity double literal\r\n:1r4:fourth;   .# ¼\r\n:1r2:half;     .# ½\r\n\r\n.#? phi: golden ratio (constant)\r\n.# Compute phi using 2 adjacent fib numbers\r\n[1000 $B, 1\\0{$@+}@%;]$1I\\0I/\r\n:phi;\r\n\r\n\r\n\r\n\r\n.########################\r\n.# Vectorized Functions #\r\n.########################\r\n\r\n\r\n{.|}:abs;           .#? N abs\\n  absolute value\r\n{1 3/^}:cbrt;       .#? N cbrt\\n  cube root\r\n{./}:ceil;          .#? N ceil\\n  ceiling\r\n{pi*180/}:deg;      .#? N deg\\n  convert deg to rad (180° => 3.14..)\r\n{180*pi/}:rad;      .#? N rad\\n  convert rad to deg (pi rad => 180)\r\n{Me}:exp;           .#? N exp\\n  exp(x)\r\n{M!}:fact;          .#? N fact\\n  factorial\r\n{.\\}:floor;         .#? N floor\\n  floor\r\n{ML2ML/}:lg;        .#? N lg\\n  base-2 log\r\n{Ml}:ln;            .#? N ln\\n  natural log\r\n{ML}:log;           .#? N log\\n  base-10 log\r\n{:%}:mod;            .#? N mod\\n  modulo\r\n{Mp}:primes;        .#? N primes\\n  returns a list containing the primes up to and including N\r\n{.!}:signnum;       .#? N signnum \\n  returns the sign of a number (1,0,-1)\r\n{.^}:sqrt;          .#? N sqrt\\n  square root\r\n{.%}:div;           .#? <NN> div\\n  integer division\r\n{%}:rem;            .#? <NN> rem\\n  remainder after division\r\n{PE}:numofdigits;   .#? N numofdignts\\n  number of digits in N\r\n\r\n.# Binary vectorized functions\r\n{2^\\2^+.^}:hypot;   .#? N hypot\\n  hypotenuse function\r\n{ML\\ML\\/}:logn;     .#? N logn\\n  base-n log\\n ex: log base 6 of 10 written as (10 6logn)\r\n\r\n\r\n.###################\r\n.# List Operations #\r\n.###################\r\n\r\n{:&2^W.^/}:normal;   .#? L<N> normal\\n  compute the normal vector of the given list\r\n{{*}/}:product;     .#? L product\\n  product of a list\r\n{*W}:vdot;           .#? LL vdot\\n  vdot product of two vectors\r\n{2^W.^}:norm;       .#? L norm\\n compute the vector norm\r\n\r\n\r\n.#? NN lcm\\n least common multiple of two numbers or a list of numbers\r\n{:& :T ::num = {.-}{{.-}/} .?}:lcm;\r\n\r\n.#? NN gcd \\n  greatest common divisor of 2 numbers or a list of numbers\r\n{:& :T ::num = {.+}{{.+}/} .?}:gcd;\r\n\r\n.#? L<N> cumsum\\n  cumulative summation of a list\r\n.{\r\n{list : sum outlist,\r\n    .# Allocate output list\r\n    0 listE L :outlist;\r\n\r\n    list.irange # {i,\r\n      list iI sum + : sum;\r\n      sum outlist i D\r\n    };\r\n\r\n    outlist\r\n}:cumsum;\r\n.}\r\n{l,lER:#{l\\.<W}}:cumsum;\r\n\r\n\r\n\r\n.#? L<N> cumprod\\n  cumulative product of a list\r\n.{\r\n{list : prod outlist,\r\n    .# Initialize prod\r\n    1:prod;\r\n\r\n    .# Allocate output list\r\n    0 listE L :outlist;\r\n\r\n    list.irange # {i,\r\n        list iI prod * : prod;\r\n        prod outlist i D\r\n    };\r\n\r\n  outlist\r\n}:cumprod;\r\n.}\r\n{l,lER:#{l\\.<{*}/}}:cumprod;\r\n\r\n\r\n\r\n\r\n\r\n\r\n.################\r\n.# Trigonometry #\r\n.################\r\n\r\n{Ms}:sin;                   .#? N sin \\n  sine\r\n{Mc}:cos;                   .#? N cos \\n  cosine\r\n{Mt}:tan;                   .#? N tan \\n  tangent\r\n{Ms1\\/}:csc;                .#? N csc \\n  cosecant\r\n{Mc1\\/}:sec;                .#? N sec \\n  secant\r\n{Mt1\\/}:cot;                .#? N cot \\n  cotangent\r\n\r\n{MS}:asin;                  .#? N asin \\n  inverse sine\r\n{MC}:acos;                  .#? N acos \\n  inverse cosine\r\n{MT}:atan;                  .#? N atan \\n  inverse tangent\r\n{1\\/MS}:acsc;               .#? N acsc \\n  inverse cosecant\r\n{1\\/MC}:asec;               .#? N asec \\n  inverse secant\r\n{1\\/MT}:acot;               .#? N acot \\n  inverse cotangent\r\n\r\n{$Me\\TMe- 2/}:sinh;          .#? N sinh \\n  hyperbolic sine\r\n{$Me\\TMe+2/}:cosh;          .#? N cosh \\n  hyperbolic cosine\r\n[{$} sinh.` {\\}\r\n     cosh.` {/}].* :tanh;   .#? N tanh \\n  hyperbolic tangent\r\n[sinh.` {1\\/}].* :csch;     .#? N csch \\n  hyperbolic cosecant\r\n[cosh.` {1\\/}].* :sech;     .#? N sech \\n  hyperbolic secant\r\n[tanh.` {1\\/}].* :coth;     .#? N coth \\n  hyperbolic cotangent\r\n\r\n{$2^1+.^+Ml}:asinh;             .#? N asinh \\n  inverse hyperbolic sine\r\n{$$1-.^\\1+.^*+Ml}:acosh;        .#? N acosh \\n  inverse hyperbolic cosine\r\n{$1\\+Ml\\1\\-Ml- .5*}:atanh;      .#? N atanh \\n  inverse hyperbolic tangent\r\n{$1\\/\\2^1\\/1+.^+Ml}:acsch;      .#? N acsch \\n  inverse hyperbolic cosecant\r\n{1\\/$$1+.^\\1-.^*+Ml}:asech;     .#? N asech \\n  inverse hyperbolic secant\r\n{1\\/$1\\-Ml\\1+Ml\\- .5*}:acoth;   .#? N acoth \\n  inverse hyperbolic cotangent\r\n\r\n\r\n\r\n.#? ::list makepoly\\n  generate a polynomial function with the given coefficients\r\n.{ Examples:\r\n    aya> [1 0 4 5] makepoly :f\r\n    {[ 3 2 1 0 ] ^ [ 1 0 4 -5 ] * W}\r\n    aya> 5 f\r\n    140\r\n    aya> [2 0] makepoly :double\r\n    {[ 1 0 ] ^ [ 2 0 ] * W}\r\n    aya> [4,double]\r\n    [ 2 4 6 8 ]\r\n.}\r\n.# {.E .R U :{2, :c ; :p} {p ^ c * W} \\ .+}:makepoly;\r\n{ [1| .E .R U {^} \\ {*W} ].* }:makepoly;\r\n\r\n\r\n\r\n.#############################\r\n.# Additional Math Functions #\r\n.#############################\r\n\r\n.# BASE\r\n\r\n{2 10  .&}:unbit;   .#? L unbit \\n  convert a list of bits to a number\r\n{10 2  .&}:bits;    .#? N bits \\n  convert a positive number to a list of bits\r\n{10 16 .&}:hex;    .#? N hex\\n  convert an int into a hex string\r\n{16 10 .&}:unhex;  .#? S unhex\\n  convert a hex string to an int\r\n\r\n\r\n\r\n.# COMBINATORICS\r\n\r\n{G}:isprime;                   .#? N isprime \\n  tests a number for primality\r\n{n r, nM! n r-M!/}:npr;        .#? NN npr\\n  permutations\r\n{n r, nM! n r- M!/ rM!/}:bin;  .#? NN bin\\n binomial (combinations)\r\n\r\n.#? N divisors \\n  returns a list of the numbers factors\r\n{n, [1 n,, n\\:%0=]}:divisors;\r\n\r\n.#? N factors\\n  compute a number's prime factors\r\n.# golf: {n,{2to(nV){n\\:%0=}.NI$n\\/f:J}{n}nGn2<|?}:f;\r\n{n,\r\n    .# is the number prime\r\n    nG n2< |\r\n\r\n    .# If the number is prime, return it\r\n    {[n]}\r\n\r\n    .# If the number is not prime, find the\r\n    .#   next factor\r\n    {\r\n        .# Range from 2..ceil(sqrt(n))\r\n        [2nV.^./]R\r\n\r\n        .# Find the next factor\r\n        {n\\:%0=}.N\r\n\r\n        .# Append this factor to the list of\r\n        .#   factors recursively\r\n        I $n\\/ factors :J\r\n    }\r\n\r\n    .?\r\n}:factors;\r\n\r\n","std/stats.aya":"require math {cumsum}\n\n.#? ::list stats.mean\\n  average of a list of numbers\ndef ::mean {\n    .E\\W\\/\n}\n\n\n.#? ::list stats.variance\\n  population variance\ndef ::variance {set : m mean^,\n    set mean:m;\n    set#{m- 2^} W setE /\n}\n\n\n.#? L stats.stdev\\n  standard deviation\ndef ::stdev {: variance^,\n    variance .^\n}\n\n\n.#? ::list stats.geomean\\n  geometric mean\n.# the nth root of the product of n numbers\n.# compute by summing the logarithms of the values\ndef ::geomean {\n    Ml.E\\W\\/Me\n}\n\n\n.#? L stats.median\\n  median value of a list\ndef ::median {l,\n    lC$E2/.\\        .# Sort the list and get its middle index\n    lE2:%0= {        .# If the list has even length,\n        $1-:JIW2/    .# average the middle two\n    } {\n        I           .# else, take the middle item\n    }  .?\n}\n\n\n.#? ::list ::list stats.regression\\n  return a block that evaluates to the regression of the sets\ndef ::regression {x y :\n    n a b\n    sumy sumx\n    sumxsq\n    sumxytimes,\n\n    xE:n;\n    x2#^W:sumxsq;\n    [x y,*]W:sumxytimes;\n    xW:sumx;\n    yW:sumy;\n\n\n    sumy sumxsq *  sumx sumxytimes * -\n    n sumxsq * sumx2^ -\n    /:a;\n\n    n sumxytimes * sumx sumy * -\n    n sumxsq * sumx2^-\n    /:b;\n\n    {b * a +} [::a ::b] .+\n}\n\n\n.#? ::list ::list stats.pearson\\n  pearson correlation coefficient between 2 datasets\ndef ::pearson {x y : n xs ys,\n    xE:n;\n    xW:xs;\n    yW:ys;\n\n    [x y,*]Wn* xs ys*-\n     x2^Wn* xs2^ -\n     y2^Wn* ys2^ -\n     * .^\n    /\n}\n\ndef ::hist {l::list nbins::num : min max bin_size bins counter cumsum^,\n    .# compute bin size using list min and max values\n    l.min :min;\n    l.max :max;\n    max min - nbins / :bin_size;\n\n    .# generate list of bins\n    .# for example, if 2:bin_size, 1:min, 5:nbins\n    .#    [ 3 5 7 9 11 ] :bins\n    bin_size nbins L cumsum min + :bins;\n\n    .# Set last bin to max value (prevent rounding errors)\n    max bins.:[-1];\n\n    .# Create a list of counters\n    [nbins,; 0] :counter;\n\n    .# Map each item to it's bin index\n    l #{bins>W}\n    .# count all bin indices\n    :# {i, counter.[i] 1 + counter.:[i]};\n\n    counter\n}\n","std/csv.aya":"{dlm : rgx,\n    \"(?<=^|$dlm)(\\\"(?:[^\\\"]|\\\"\\\")*\\\"|[^$dlm]*)\" :rgx; .#\"\n    '\\n' S :# {line,\n        line.trim :line;\n        line rgx & :#{.trim .rmquote .!}\n    }\n} :parse;\n\n{f : parse^,\n    fP G \",\" parse\n} :open;\n\n{kwargs::dict : parse^\n                                clabel(1) .# bool\n                                rlabel(::nil) .# bool\n                                filename(::nil) .# str\n                                csv_str(::nil) .# str\n                                dlm(\",\")\n                                data\n                                colnames(::nil) .# ::list\n                                rownames(::nil) .# ::list\n                                ,\n    kwargs ~\n\n    (csv_str ::nil = filename ::nil = &) {\"Must provide either filename or csv_str\" .D} ?\n\n    .# Open the file and read into data\n    filename ::nil =! {filenameP G :csv_str;} ?\n\n    csv_str dlm parse :data;\n\n    .# Attempt to auto-detect rlabel if it is not specified\n    rlabel ::nil = {\n        data.[0].[0] \"\" = {\n            1 :rlabel;\n        } {\n            0 :rlabel;\n        } .?\n    } ?\n\n    .# CSV has column headers\n    clabel {\n        data V :colnames; ;\n        .# If there are row labels, the first entry is for the index colum\n        rlabel {colnamesV;:colnames;} ?\n    } ?\n\n    rlabel {\n        data :#{V\\;} :rownames;\n    } ?\n\n    :{\n        data:data\n        colnames:colnames\n        rownames:rownames\n    }\n} :_read_kw;\n\n\n{ arg : _read_kw^ ,\n    {\n        (arg :T ::str =) {\n            .# convert to dict\n            :{ arg :filename }\n        } (arg :T ::dict =) {\n            arg\n        } {\n            \"Unsupported arg type $(arg:T). Must be ::str or ::dict\" .D\n        }\n    } :?\n\n    _read_kw\n} :read;\n\n\n.#? list sep na csv.dumps\\n  convert a 2d list to a csv string\n{list sep na,\n    list :# {\n        :#{\n            .# If it is na, make it emptystr\n            :& na = {;\"\"} ?\n            .# If it is a string, surround with quotes\n            :& P \\ ::str :@ {\"\\\"\"+ \"\\\"\"\\+} ?\n        }\n        sep %\n    } \"\\n\" %\n} :dumps;\n\n\n","std/set.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# set.aya\r\n.# Defines the set data structure\r\n\r\n.{? type: set\r\n    The set type is a simple list type where there exits no duplicate elements.\r\n    Create a set by entering a list followed by the set constructor\r\n.}\r\n\r\n\r\nclass set\r\n\r\ndef set::__init__ {l::list self,\r\n    l self.:list ;\r\n}\r\n\r\n\r\n.#\r\n.# Adding / Removing elements\r\n.#\r\n\r\n.#? ::any ::set.__add__\\n  add an item to a set\r\ndef set::__add__ {item self,\r\n    item self.in ! {self.list [item] :J;} ? self\r\n}\r\n\r\n.#? ::any ::set.__sub__\\n  remove an item from a set\r\ndef set::__sub__ {item self,\r\n    self.list [item] :| self.:list\r\n}\r\n\r\n\r\n\r\n.#\r\n.# Set operations\r\n.#\r\n\r\n.#? ::set ::set.__or__\\n  set union\r\ndef set::__or__ {other::set self,\r\n    other.list $ \\; self.list :J :~ self.M!\r\n}\r\n\r\n.#? ::set ::set.__and__\\n  set intersection\r\ndef set::__and__ {other::set self : l,\r\n    self.list :l;\r\n    other.list # {l \\N$ 0:> {I} {;;} .?} self.M!\r\n}\r\n\r\n\r\n.#? ::set ::set.__div__\\n  set difference\r\ndef set::__div__ {other::set self,\r\n    other.list $\\; self.list :| self.M!\r\n}\r\n\r\n\r\n.#? ::set ::set.__eq__\\n test if two sets are the same\r\ndef set::__eq__ {other::set self,\r\n    other.list self.list =\r\n}\r\n\r\n\r\n.#? ::set ::set.__lt__\\n  proper subset\r\ndef set::__lt__ {other::set self,\r\n    other self.__leq__            .# subset\r\n    other.list self.list = !  .# proper subset\r\n    &\r\n}\r\n\r\n.#? ::set ::set.__gt__\\n  proper subset\r\ndef set::__gt__ {\\.__lt__}\r\n\r\n\r\n.#? ::set ::set.__leq__\\n subset\r\ndef set::__leq__ {other::set self : l,\r\n    other.list :l;\r\n    self.list # { l \\ N \\; 0 :>} {*} %\r\n}\r\n\r\n.#? ::set ::set.__geq__\\n subset\r\ndef set::__geq__ {\\.__leq__}\r\n\r\n\r\n\r\n.#\r\n.# Other functions\r\n.#\r\n\r\n.#? ::any ::set.in\\n  tests if an item is in a set\r\ndef set::in {item self,\r\n    self.list item N\\; 0 :>\r\n}\r\n\r\n\r\n.#? ::set.__len__\\n  returns the number of elements in the set\r\ndef set::__len__ { .list E }\r\n\r\n\r\n.#? ::set.clear\\n  clear the contents of a set\r\ndef set::clear {[]\\ .:list}\r\n\r\ndef set::__repr__ {.listP\"s\"\\+}\r\ndef set::__str__  {.listP\"s\"\\+}\r\n\r\ndef set::__each__ {blk self,\r\n    self.list :# {blk}\r\n}\r\n\r\n\r\n{:set^, set {~\\!} 0 :`}:s;\r\n","std/dataframe.aya":"import csv\n\nclass dataframe\n\ndef dataframe::__init__ {kwargs::dict self :\n        data(::nil)\n        colnames(::nil)\n        index(::nil),\n\n    kwargs ~\n\n    [] self.:_colnames;\n    [] self.:_index;\n    [] self.:_data;\n\n    .# Create using data\n    data ::nil =! {:numrows numcols,\n        data E :numrows;\n        data .TE :numcols;\n        data self.:_data;\n\n        .# Column names\n        colnames ::nil = {\n            numcols self.M._gen_colnames\n        } {\n            colnames\n        } .? self.:_colnames;\n\n        .# Row names\n        index ::nil = {\n            numrows .R\n        } {\n            index\n        } .? self.:_index;\n    } ?\n\n    self._check_size\n}\n\ndef dataframe::_check_size {self,\n    self._dataE self._indexE = ! {\n        \"dataframe!: data size ($(self._dataE)) and index length ($(self._indexE)) do not match\" .D\n    } ?\n\n    self._data.TE self._colnamesE = ! {\n        \"dataframe!: data num cols ($(self._data.TE)) and length of colnames ($(self._indexE)) do not match\" .D\n    } ?\n}\n\ndef dataframe::_gen_colnames {n::num cls,\n    n 26 :< {\n        ['a $nV+] R#P\n    } {\n        n 26- :n;\n        \"az\"R#P\n        n 26 .% 'a$@+ :J R \"az\"R {\\P+}.pu #~ n .< :J\n    } .?\n}\n\n.# CSV Utils\n.###########\n\ndef dataframe::from_csv {csv_dict cls,\n    :{\n        csv_dict.data :data;\n        csv_dict.rownames :index;\n        csv_dict.colnames :colnames;\n    } dataframe!\n}\n\ndef dataframe::read_csv {arg cls: dataframe^ csv^ ,\n    .# csv.read takes a string or a kwargs dict\n    arg csv.read dataframe.from_csv\n}\n\ndef dataframe::to_csv { kwargs self : csv^ noindex(0) colnames(1) sep(\",\"), kwargs ~\n    self._data \n    colnames { self._colnames A \\ J } ?\n    noindex! { \n        self._index\n        colnames {[\"\"] \\ J} ?\n        \\ {J} .&\n    } ?\n    sep nil\n    csv.dumps\n}\n\n.# Indexing\n.##########\n\ndef dataframe::_get_col_index {colname self,\n    colname :T ::sym = {colname :C :colname; } ?\n    self._colnames colname N\\; :colindex;\n    colindex 0 < {\n        \"Column $colname not found\" .D\n    } ?\n    colindex\n}\n\ndef dataframe::_get_col {colname self : colindex,\n    colname self._get_col_index :colindex;\n    self._data :# { colindex I }\n}\n\ndef dataframe::_numgetindex {index::num self : dataframe^ idx,\n    .# Lookup the index in _index\n    self._index index N :idx;\n\n    idx 0 :> {\n        :{\n            [self._data.[idx]]  :data;\n            [self._index.[idx]] :index;\n            self._colnames :colnames;\n        } dataframe!\n    } {\n        \"Index $num does not exist in df._index\" .D\n    } .?\n}\n\ndef dataframe::__getindex__ { index self : dataframe^,\n    .# If input is a number, look up that row, return a dataframe\n    .# If input is a string, look up that column, return a list\n    .# If input is a list, use it as a row mask, return a dataframe\n    {\n        (index :T ::num =) {\n            index self._numgetindex\n        } (index :T ::str =) {\n            index self._get_col\n        } (index :T ::list =) {\n            index E self._data E = {\n                :{\n                    self._data index .i :data;\n                    self._index index .i :index;\n                    self._colnames :colnames;\n                } dataframe!\n            } {\n                \"List length must match row length\" .D\n            } .?\n        } {\n            \"Unsupported index: $index\" .D\n        }\n    } :?\n}\n\n.{\n    aya> df\n        A B C\n    0 | 1 2 3\n    1 | 4 5 6\n    2 | 7 8 9\n    aya> df.row[1]\n        A B C\n    0 | 4 5 6\n    aya> df.row[[1 2]]\n        A B C\n    0 | 4 5 6\n    1 | 7 8 9\n.}\ndef dataframe::row {(1 hold)({self index : data,\n    self._data.[index~]:data;\n    [ index~ :T ::num = { [data]:data } ? ];\n\n    :{ self._colnames:colnames data:data } dataframe!\n})}\n\n\n.{\n    aya> df\n        A B C\n    0 | 1 2 3\n    1 | 4 5 6\n    2 | 7 8 9\n    aya> \"C\" {5>} df.filter_on_col\n        A B C\n    0 | 4 5 6\n    1 | 7 8 9\n.}\ndef dataframe::filter_on_col {column condition self : colindex,\n    column self._get_col_index :colindex;\n    self.row[ { .[colindex] condition } ]\n}\n\n\ndef dataframe::nrows {self,\n    self._data E\n}\n\ndef dataframe::ncols {self,\n    self._data.[0] E\n}\n\ndef dataframe::shape {self,\n    [self.nrows self.ncols]\n}\n\ndef dataframe::colnames {self,\n    self._colnames\n}\n\ndef dataframe::rows {self,\n    self._data\n}\n\n\n.# Serialization / Output\n.########################\n\ndef dataframe::__str__ {self : max_idx_len,\n    .# find longest index name\n    self._index #{PE} .max :max_idx_len;\n    .# pad indices to lo\n    self._index :#{P max_idx_len .> \" |\" +}\n    .# Zip the index and the data along each row\n    self._data {J}.&\n    .# Add a \"\" to the front for the index column\n    \"\" self._colnames#P J\n    .# Add the colum as the first elemnt in the list\n    A\\J\n    .# Convert to a pretty matstr\n    .matstr\n}\n\ndef dataframe::to_html {kwargs::dict self : noindex(0) data style(\"\") border(0),\n    kwargs ~\n    self._data :data;\n    noindex ! {\n        self._index self._data {J} .& :data;\n    } ?\n\n    [] :out;\n    \"<table style=\\\"$style\\\" border=\\\"$border\\\">\" out.B;\n    data :# {row,\n        \"<tr>\" out.B;\n        row :# {x, \"<td>$x<\/td>\" out.B } ;\n        \"<\/tr>\" out.B;\n    } ;\n    \"<\/table>\" out.B;\n\n    out W\n}\n\ndef dataframe::_repr_lines {s::str cls : lines,\n    s.lines :lines;\n    lines E 24 > {\n        [lines 10 .<~ \"...\" lines 10 .>~]\"\\n\" %\n    } {\n        s\n    } .?\n}\n\n\ndef dataframe::__repr__ {self : dataframe^,\n    self.__str__ dataframe._repr_lines\n}\n","std/image.aya":"require io {path}\n\nclass image\n\ndef image::__init__ {r g b a width height meta self,\n    r self.:r;\n    g self.:g;\n    b self.:b;\n    a self.:a;\n    width self.:width;\n    height self.:height;\n    meta self.:meta;\n}\n\ndef image::read {filename cls : img image^ path^,\n    filename :(image.read) :img;\n    img.r img.g img.b img.a img.width img.height img.meta image!\n}\n\ndef image::__repr__ {self,\n    \"(image $(self.width)x$(self.height))\"\n}\n\ndef image::write {filename self : path^,\n    self filename :(image.write)\n}\n\ndef image::pixels {self,\n    [self.r self.g self.b self.a] .T\n}\n\ndef image::pixels_rgb {self,\n    [self.r self.g self.b] .T\n}\n\ndef image::channels {self,\n    [self.r self.g self.b self.a]\n}\n","std/json.aya":"require io {file}\n\n{:(json.loads)} :loads;\n\n{:(json.dumps)} :dumps;\n\n{json_file : file^ loads^,\n    json_file :T ::str = {\n        json_file 'r file! :json_file;\n    } ?\n\n    json_file.do {f,\n        f.readall loads\n    }\n} :load;\n\n{data json_file : file^ dumps^,\n    json_file :T ::str = {\n        json_file 'w file! :json_file;\n    } ?\n\n    json_file.do {f,\n        data dumps f.print;\n    }\n} :dump;\n","base/importlib.aya":":{} :importlib;\n\nimportlib __aya__.:importlib;\n\n\"\"\"\n# importlib\n\nDefines two global keywords: import & require\n\n## `import`\n\n`import <module>`: import the module and assign it to the module name\n\n### Example\n\nAssume \"sample.aya\" has variables \"foo\" and \"bar\"\n\n`import sample` will define the variable `sample` to the dict `:{ ...:foo ...:bar}`.\nUse `sample.foo` & `sample.bar` to access imported names\n\n### Valid import statements\n\n  - Standard imports: Search for files in \"<importlib._path>/<name>.aya\"\n    - import \"example\"\n    - import \"example.aya\" (extension optional, no extension preferred)\n\n  - Relative imports: Search for files relative to the file with the import statement\n    - import \".relative\"\n    - import \".relative.aya\" (extension optional, no extension preferred)\n    - import \".src/relative.aya\"\n\n  - Package imports: If the import points to a directory, it will look for <path>/__pkg__.aya\n    - import \"src/package\" (assumes src/package/__pkg__.aya exists)\n\n  - Identifier imports: Itentifiers will be converted to strings before importing\n    - import example (same as import \"example\")\n    - import .example (ERROR: Will import \"exmaple\" not \".example\")\n    - Use with a SINGLE IDENTIFIER ONLY! Anything after the first identifier is treated as\n      a nomal aya expression\n      - import foo.bar (Parsed as {(import foo) .bar} )\n      - import foo/bar (Parsed as {(import foo) / bar} )\n\n  - Multiple imports: Wrap multiple imports in a block\n    - import {foo bar}\n    - import {example \"./src/foo\"} (same rules as above apply, can be an identifier or string)\n\n## `require`\n\nRequire is similar to import but imports names directly into the current scope. \nYou can specify which names to import or import all with a wildcard.\nWhen using the wildcard, names with a leading underscore will not be imported\n\n### Example\n\nAssume \"sample.aya\" has variables \"foo\", \"bar\", and \"_baz\"\n\n  - `require sample {foo}` will bring `foo` into the current scope. `sample` and `sample.bar` are undefined\n  - `require sample {foo bar}` will bring `foo` and `bar` into the current scope\n  - `require sample *` will bring `foo` and `bar` into the current scope. `_baz` will not be imported\n    since it has a leading underscore\n  - `require sample {foo _baz}` will bring `foo` and `_baz` into the current scope even though _baz has a leading underscore\n\n### Valid require statements\n\n - Bring sin, cos, and tan into scope\n   - require math {sin cos tan}\n   - require \".math\" {sin cos tan}\n - Like imports, strings and identifiers are interchangable (identifiers preferred when possible)\n   - require \"math\" {\"sin\" \"cos\" \"tan\"}\n   - require \"./src/math\" {\"sin\" \"cos\" \"tan\"}\n - Require * will bring all variables that do not start with a leading _ into scope\n   - require math *\n   - require \"./src/math\" *\n\n\"\"\";\n\n\n.#\n.# Utility Functions\n.#\n\n.# Join paths a and b in a portable way\ndef importlib::_join_path {a::str b::str,\n    a b :(sys.joinpath)\n}\n\n\"a\" \"b\"  importlib._join_path [\"a\" :9s \"b\"] W :!\n\"a/\" \"b\" importlib._join_path [\"a\" :9s \"b\"] W :!\n\n\n.#\n.# Importlib Variables\n.#\n\n.# If true, allow printing debug information\ndef importlib::_debug 0\n\n.# While processing an import, this will keep track of imports\n.# inside of other imports. The top of the stack (.[-1]) is \n.# always the current file being imported\ndef importlib::_import_stack []\n\n.# Dictionary of files which have been imported\n.#  maps filename -> imported module (dict)\ndef importlib::_imported :{}\n\n.# List of absolute paths to imported jar files\n.# def importlib::loaded_jars []\n\n.# List of locations where we are looking for files to import\n.# Should always use get_path since it will append the current directory\n.# By default, we add the standard library \ndef importlib::_path [\n    .# Standard library: \"<aya-dir>/std\"\n    :(sys.ad) \"std\" importlib._join_path\n    .# Default packages location: \"<aya-dir>/pkg\"\n    :(sys.ad) \"pkg\" importlib._join_path\n]\n\n\n.#\n.# Main API\n.#\n\n\ndef importlib::import {__name::str : __path importlib^,\n    __name importlib._resolve_name_to_path :__path;\n\n    .# Special case, if the file is a jar, use library.load\n    __path \".jar\" importlib._endswith {\n        __path :(library.load)\n    } {\n\n        .# Get the name of the identifier to assign to\n        __path importlib._filename_no_extension .# str\n\n        :& \"__pkg__\" = {\n            ; .# pop \"__pkg__\"\n            .# replace it with the package name\n            __path :(sys.parent) importlib._filename_no_extension\n        } ?\n\n        __path importlib._load_file .# dict\n\n        .# Assign the dict to the identifier\n        \\ := ;\n    } .?\n}\n\n.# __symbols ::list|::num\n.# if symbols is 1, then import all public names\ndef importlib::require {__name::str __symbols : importlib^,\n    __name importlib._resolve_name_to_path importlib._load_file .# dict\n\n    __symbols 1 = {\n        .# require all names that don't start with \"_\"\n        :# { \\ :& :C .[0] '_ =! {:=} ? .A} ;\n    } {\n        .# require specified names\n        __symbols importlib._bring_names_into_scope\n    } .?\n}\n\n.#\n.# Keywords\n.#\n\n.# keyword: import\n.# See module documentation for valid import format\n{{\n    .[0] .# :` wraps args in a list; dump it to the stack\n    __aya__.importlib._parse_identifiers :# {\n        __aya__.importlib.import \n    };\n} 1:` }:import;\n\n\n.# keyword: require\n.# See module documentation for valid import format\n{{\n    .# Args from :` come wrapped in a list; dump both to the stack\n    ~\n    .# require foo *\n    .# bring all public names into scope\n    .# Not really a better way to check this at the moment so we just\n    .#   use string conversion\n    :& P \"{*}\" = {\n        ; 1\n    } {\n        __aya__.importlib._parse_identifiers :# {:S}  .# symbols\n    } .?\n    \\\n    __aya__.importlib._parse_identifiers.[0]      .# name\n    \\ __aya__.importlib.require\n} 2:` }:require;\n\n\n.#\n.# Helper Functions\n.#\n\n.# stack args:\n.#   dict\n.#   list[symbol]\ndef importlib::_bring_names_into_scope { {$@\\I\\:=} :O ; }\n\n:{ :{ 1:a 2:b 3:_c} [::a ::_c] importlib._bring_names_into_scope } :{ 1:a 3:_c } :!\n:{ :{ 1:a 2:b 3:_c} [::a] importlib._bring_names_into_scope } :{ 1:a } :!\n:{ :{ 1:a 2:b 3:_c} [] importlib._bring_names_into_scope } :{ } :!\n\n\ndef importlib::_log_debug {:importlib^,\n     importlib._debug {\"importlib: \" \\+ :P} {;} .?\n}\n\n.# Return the path with the current directory at the bottom\ndef importlib::get_path { : importlib^ ,\n    importlib._path\n    :(sys.wd)\n    J\n}\n\n.# Get the filename with extensions removed\n.# All extensions are removed\n.# \"/foo/bar/baz.aya\" => \"baz\"\n.# \"/xyz/abc.def.ghi\" => \"abc\"\ndef importlib::_filename_no_extension {path::str,\n    path :(sys.get_filename) \"\\.\"S.[0]\n}\n\n\"/foo/bar/baz.aya\" importlib._filename_no_extension \"baz\" :!\n\"/xyz/abc.def.ghi\" importlib._filename_no_extension \"abc\" :!\n\n\n.# str::str suffix::str _endswith\n.# \"foo.aya\" \".aya\" _endswith => 1\ndef importlib::_endswith { :& E@\\.>= }\n\n\"foo.aya\" \".aya\" importlib._endswith 1 :!\n\"foo.txt\" \".aya\" importlib._endswith 0 :!\n\n.# Convert a name to a path\n.# \n.# args:\n.#   name::str : a valid import name\n.#      - \"example\"\n.#      - \"example.aya\"\n.#      - \".relative\"\n.#      - \".relative.aya\"\n.#      - \".src/relative.aya\"\n.#      - \"src/package\" (assumes src/package/__pkg__.aya exists\n.#\n.# If a name has a leading \".\" resolve it to a path relative\n.#   to the file currently being imported (not relative to the\n.#   working dir)\n.# Otherwise, search the importlib._path for locations the file could be\n.# Check the following three files:\n.#   - \"_path/<name>\" (an exact match)\n.#   - \"_path/<name>.aya\" (append aya file extension)\n.#   - \"_path/<name>/__pkg__.aya\" (package path)\n.# \n.# Return the absolute path that was found. Only one path is returned\ndef importlib::_resolve_name_to_path {name::str : path_to_import importlib^ files_to_check valid_paths,\n    .# Sanity check: make sure we didn't pass an empty path\n    name \"\" = {\"Empty import\" .D} ?\n\n    .# First we need to check if it is a relative import\n    name.[0] '. = {: rel_path,\n        .# If a path starts with a \".\" we need to join it with path\n        .# from the top of the import stack\n        .# If the import stack is empty, use working directory\n        importlib._import_stack E 0 = {\n            :(sys.wd)\n        } {\n            importlib._import_stack.[-1] :(sys.parent)\n        } .?\n\n        .# Drop the leading \".\" from \n        name.E 1- .>\n        importlib._join_path :rel_path;\n\n        [\n            rel_path\n            rel_path \".aya\" +\n            rel_path \"__pkg__.aya\" importlib._join_path\n            rel_path \".aya\" + \"__pkg__.aya\" importlib._join_path\n        ] :files_to_check;\n\n    } {\n        .# If it is not a relative import, we need to search for it in the import path\n        importlib.get_path :# {path_entry,\n            path_entry name importlib._join_path :path_entry;\n            path_entry .# regular name\n            path_entry \".aya\" + .# name.aya\n            path_entry \"__pkg__.aya\" importlib._join_path .# package\n            path_entry \".aya\" + \"__pkg__.aya\" importlib._join_path .# .aya package\n        } :files_to_check;\n    } .?\n\n\n    files_to_check :~ .[{:(sys.file_exists)}] :valid_paths;\n\n    valid_paths E 1 > { \"Import error: Multiple valid paths found for import: $valid_paths\" .D } ?\n    valid_paths E 0 = { \"Import error: Unable to find any files in path: $files_to_check\" .D} ?\n\n    .# Exactly 1 file exists, that is the path to import\n    valid_paths.[0] :path_to_import;\n\n    .# Now that we have the path to import, lets load it\n    path_to_import :(sys.abspath) .# importlib._load_file :imported;\n}\n\n\n.# Import a file\n.# args:\n.#   - path_to_import::str : The resolved absolute path to the aya file\n.#\n.# return: the imported file as a dict\ndef importlib::_load_file {path_to_import::str : importlib^,\n    .# Have we imported this already?\n    importlib._imported path_to_import H {\n        .# If we've already imported the file, just return the dict\n        importlib._imported.[path_to_import]\n    } {\n        .# Push the path we are importing onto the import stack\n        path_to_import importlib._import_stack .B;\n\n        {\n            .# Open a new scope\n            :{\n                0 :__main__;\n\n                .# Load the file\n                path_to_import :F\n            }\n            .# Now that import is complete, remove __main__\n            ::__main__ .-\n        } {ex,\n            .# There was an error importing\n            .# pop from the import stack\n            importlib._import_stack B;;\n            ex .D .# re throw error\n        } .K\n\n        .# pop from the import stack\n        importlib._import_stack B;;\n\n        .# Add dict to imported cache\n        :& .# Keep dict on the stack\n        importlib._imported.:[path_to_import];\n    } .?\n\n    .# the imported dict is left on the stack\n}\n\n.# A file is main if `__main__` is undefined or not 0\ndef importlib::is_main {\n    { .# try\n        __main__ 0 =!\n    } {;\n        1\n    } .K\n}\n\ndef ::main {{\n    ~ __aya__.importlib.is_main {~} ?\n} 1 :`}\n\n\n.# Convert a block containing symbols or strings to a list of strings\ndef importlib::_block_to_str_list {b::block,\n    b.` .* :# {x,\n        x.` :S .E 1= {\n            .# If it is a symbol it will be converted to [::symbol]\n            .# Use .[0] to get the symbol object\n            .[0] :C\n        } {\n            .# If it is not a symbol it will be converted to []\n            .# evaluate the block x to get the original string\n            ; x\n        }.?\n    }\n}\n\n.# Tests\n{sin cos \"Asin\" \"Acos\"} importlib._block_to_str_list\n    [ \"sin\" \"cos\" \"Asin\" \"Acos\" ] :!\n\n.# Convert a block containing symbols or strings to a list of symbols\n.# aya> {sin cos \"Asin\" \"Acos\"} .* :# {x, x.` :S .E 1= {~:C} {; x.`~}.? :S}\n.# [ ::sin ::cos ::\"Asin\" ::\"Acos\" ]\ndef importlib::_block_to_symbol_list {:importlib^,\n    importlib._block_to_str_list #:S\n\n}\n\n.# Tests\n{sin cos \"Asin\" \"Acos\"} importlib._block_to_symbol_list\n    [ ::sin ::cos ::\"Asin\" ::\"Acos\" ] :!\n\n\n.# stack args:\n.#  list[block[str|identifier]]\ndef importlib::_parse_identifiers {\n    importlib._block_to_str_list\n\n    .# If still a block, we need to parse one level deeper\n    .# We do not handle any additional nested blocks\n    :&.[0] ::block :@ {\n        .[0] .* :#{\n            importlib._block_to_str_list.[0]\n        }\n    } ?\n}\n\n{foo} importlib._parse_identifiers\n    [ \"foo\" ] :!\n{foo bar} importlib._parse_identifiers\n    [ \"foo\" \"bar\" ] :!\n{foo \"baz\"} importlib._parse_identifiers\n    [ \"foo\" \"baz\" ] :!\n{foo \"baz\" \"./src/foo.txt\"} importlib._parse_identifiers\n    [ \"foo\" \"baz\" \"./src/foo.txt\" ] :!\n{\"./src/foo.txt\"} importlib._parse_identifiers\n    [ \"./src/foo.txt\" ] :!\n\n\ndef importlib::load_library {jar_file : importlib^,\n    importlib.loaded_jars jar_file H ! {\n        jar_file :(library.load) ;\n        jar_file importlib.loaded_jars .B ;\n    } ?\n}\n\nimportlib __aya__.:importlib;\n","std/matrix.aya":"import mp\n\nclass matrix\n\n.# Test if list is a valid matrix\ndef matrix::_is_valid_list {m::list matrix,\n    .# Both of the following must be true:\n    m :#{:T::list=} .allt   .# The list is made up of only other lists\n    {\n        m :#{Em0IE=} .allt  .# All of the list lengths are the same\n    } 0 .?\n}\n\ndef matrix::__init__ {input::list self,\n    input self.M._is_valid_list {\n        input self.:rows;\n    } {\n        \"$input is not a valid matrix\" .D\n    } .?\n}\n\n.# Use this instead of the constructor to avoid\n.# validating the list\ndef matrix::_new {matrix,\n    :{rows,} matrix :M\n}\n\n.{ Example:\n    aya> [3 3] matrixR 10^\n    [[ 1         1024       59049      ]\n     [ 1048576   9765625    60466176   ]\n     [ 282475249 1073741824 3486784401 ]]\n.}\ndef matrix::__repr__ {self,\n    self.r self.c + 100 > {\n        \"($(self.r)x$(self.c) matrix)\"\n    } {\n       self.rows .matstr \"\\n\" \" ]\\n [ \" .& \"[[ \" \\+ \" ]]\"+\n    } .?\n}\n\n\n.# Vectorized Operator Overloads\n.###############################\n\n.# Binary\n.# ------\n\n[\n    ::__sub__ ::__div__\n    ::__pow__ ::__lt__  ::__gt__  ::__mod__\n    ::__leq__ ::__geq__ ::__idiv__\n] :# {op_sym : mp^ op_to_n op rop rop_sym,\n    \n    [::n op_sym] mp.merge :op_to_n;\n    op_sym.op :op;\n    [::other {\\} op_sym] mp.merge :rop;\n    op_sym.rev :rop_sym;\n\n    def matrix op_sym {other self : op^ rop^,\n        {\n            (other :T ::matrix =) {\n                other.rows self.rows op.` .& self.M._new\n            } (other :T ::num =) {\n                self.rows :# rop.` self.M._new\n            } { \n                \"TypeError: Invalid operation $(other:T) $(self:T) *\" .D\n            }\n        } :?\n    }\n\n    def matrix rop_sym {self n::num : op_to_n^, self.rows :# {op_to_n} self.M._new}\n}\n\ndef matrix ::__mul__ { other self,\n    {\n        (other :T ::matrix =) {\n            selfE otherE = {\n                other.rows self.rows {*} .& self.M._new\n            } {\n                self.rows other.rows  {{*}:*{~}O}:*{~}O self.M._new\n            } .?\n        } (other :T ::num =) {\n            self.rows {other *} O self.M._new\n        } {\n            \"TypeError: Invalid operation $(other:T) $(self.T) *\" .D\n        }\n    } :?\n}\n\ndef matrix::__rmul__ {self n::num,\n    self.rows [n {*}].* O self.M._new\n}\n\ndef matrix::matmul {other self, \n    other.rows self.rows :(la.mul) self.M._new\n}\n\ndef matrix ::__add__ { other self,\n    {\n        (other :T ::matrix =) {\n            selfE otherE = {\n                other.rows self.rows {+} .& self.M._new\n            } {\n                self.rows other.rows  {{+}:*{~}O}:*{~}O self.M._new\n            } .?\n        } (other :T ::num =) {\n            self.rows {other \\+} O self.M._new\n        } {\n            \"TypeError: Invalid operation $(other:T) $(self.T) *\" .D\n        }\n    } :?\n}\n\ndef matrix::__radd__ {self n::num,\n    self.rows {n +} O self.M._new\n}\n\n\n\n\n.# Unary\n.# -----\n[\n    ::__floor__ ::__ceil__ ::__negate__ ::__abs__ ::__signnum__\n    ::__sqrt__ ::__exp__ ::__ln__ ::__log__\n    ::__sin__ ::__asin__ ::__cos__ ::__acos__ ::__tan__ ::__atan__\n] :# {sym : op,\n    sym.op :op;\n    def matrix sym ({\n        :& .rows op #~ \\.M._new\n        } :{ op.`:op } .+\n    )\n}\n\n.# Other Overloads\n.# ---------------\n\n\ndef matrix::_eq_num {n self,\n    self.rows n .= self.M._new\n}\n\ndef matrix::_eq_list {l self,\n    self.rows :# {\n        .# Test if the current item is in the list\n        :# {l \\ H}\n    } self.M._new\n}\n\ndef matrix::_eq_mat {a b,\n    aE bE =! 0 {a.rows b.rows =} .?\n}\n\n.#? ::matrix ::matrix =\\n  test if two matrices are equal\n.#? ::list ::matrix =\\n  return a matrix of booleans where true if the corresponding element is in the input list\n.#? ::num ::matrix =\\n  return a matrix of booleans there true if the corresponding element is equal to the input number\ndef matrix::__eq__ ({a b,\n    a b\n    .# swap args if b is not a matrix\n    b :T ::matrix =! {\\} ?\n    __fn 3.$ :T I ~\n} :{\n    :{\n        matrix._eq_list.` :list;\n        matrix._eq_num.`  :num;\n        matrix._eq_mat.`  :matrix;\n    }:__fn\n} .+)\n\n\n.#? ::matrix ::matrix &\\n  element-wise and\ndef matrix::__and__ {:matrix^, .rows\\.rows {{&}.&}.& matrix._new}\n\n.#? ::matrix ::matrix |\\n  element-wise or\ndef matrix::__or__  {:matrix^, .rows\\.rows {{|}.&}.& matrix._new}\n\n\n\n\n.#####################\n.# Matrix Operations #\n.#####################\n\n.#? ::matrix ::matrix.sq\\n  square each value in the matrix\ndef matrix::sq { :& * }\n\n\n.#? ::matrix matrix.issq\\n  returns true if the list is a square matrix\ndef matrix::issq {self, self.rowsE self.rows#E\\#= `| %}\n\n.#? ::matrix matrix.tr\\n  trace of a matrix as a list\ndef matrix::tr {[1|.rows$ER,VI]}\n\n.#? ::matrix matrix.t\\n  transpose a matrix\ndef matrix::t {:&.rows.T\\.M._new}\n\n.#? ::matrix.max\\n  the max value of a matrix\ndef matrix::max {.rows#.max.max}\n\n.#? ::matrix.min\\n  the min value of a matrix\ndef matrix::min {.rows#.min.min}\n\n.#? ::matrix.norm\\n  normalize the matrix\ndef matrix::norm {:& .sq .sum .^ /}\n\n.#? ::matrix.sum\\n  the sum of all values in the matrix\ndef matrix::sum {.rows #WW}\n\n.#? ::matrix.mean\\n  the mean of all values in the matrix\ndef matrix::mean {.E~* \\.sum\\/}\n\ndef matrix::dot {o self : t matrix^,\n    o.c self.r =! {\n        \"matrix.mul: shape mismatch $(o.c) != $(self.r)\".D\n    } ?\n    .# (*W) is the dot product\n    self.rows.T :t;\n    o.rows  :# {r, t :#{r *W}}\n    matrix._new\n}\n\n.#? ::matrix.r\\n  number of rows\ndef matrix::r {.rowsE}\n\n.#? ::matrix.c\\n  number of cols\ndef matrix::c {.rows.[0] E}\n\n.###################\n.# Transformations #\n.###################\n\n.#? ::matrix ::matrix.hcat\\n  concatenate horizontally\ndef matrix::hcat {a::matrix b::matrix,\n    a.rows b.rows {J} .& a.M._new\n}\n\n.#? ::matrix ::matrix.vcat\\n  concatenate vertically\ndef matrix::vcat {a::matrix b::matrix,\n    a.rows b.rows J a.M._new\n}\n\n.#? ::num ::matrix.rotate_cols\\n  shift columns of a matrix right N times\n.#? ::num ::matrix.rotate_rows\\n  shift rows of a matrix down N times\n.{ Example:\n    aya> [3 3]matrixR\n    [[ 1 2 3 ]\n     [ 4 5 6 ]\n     [ 7 8 9 ]]\n\n    aya> 1 [3 3]matrixR.rotate_rows\n    [[ 7 8 9 ]\n     [ 1 2 3 ]\n     [ 4 5 6 ]]\n\n    aya> 1 [3 3]matrixR.rotate_cols\n    [[ 3 1 2 ]\n     [ 6 4 5 ]\n     [ 9 7 8 ]]\n.}\ndef matrix::rotate_cols {:matrix^,\n    .rows \\ #{\\.rotate} matrix._new\n}\n\ndef matrix::rotate_rows {:matrix^,\n    .rows .rotate matrix._new\n}\n\ndef matrix::circshift {rc self : m,\n    rc.[0] self.rotate_rows :m;\n    rc.[1] m.rotate_cols\n}\n\n.#? [rows cols] ::matrix .<\\n  cut or pad the matrix to the given size from the upper left corner\n.{? Example:\n\n    aya> [2 2] matrixR [3 3] .<\n    [[ 1 2 0 ]\n     [ 3 4 0 ]\n     [ 0 0 0 ]]\n\n    aya> [2 2] matrixR [3 2] .<\n    [[ 1 2 ]\n     [ 3 4 ]\n     [ 0 0 ]]\n\n    aya> [2 2] matrixR [3 1] .<\n    [[ 1 ]\n     [ 3 ]\n     [ 0 ]]\n\n    aya> [2 2] matrixR [2 3] .<\n    [[ 1 2 0 ]\n     [ 3 4 0 ]]\n\n    aya> [2 2] matrixR [1 3] .<\n    [[ 1 2 0 ]]\n.}\ndef matrix::__head__ {self n::list : d,\n    n E 2 =! {\"dimension of take must be 2\" .D} ?\n\n    .# rows\n    self.rows n.[1] #.<\n\n    .# cols\n    .# Pad the list with 0s\n    n.[0] .<\n    .# create empty list equal to the length of the first element\n    .# ex: cols=5 then create [0 0 0 0 0]\n    0 dot_i E 0\\L :d;\n    .# Replace 0s with the empty list\n    :# {$ 0 = {;d} ?}\n\n    self.M._new\n}\n\n\n.#? [rows cols] ::matrix .<\\n  cut or pad the matrix to the given size from the bottom right corner\ndef matrix::__tail__ {self n::list : d,\n    n E 2 =! {\"dimension of take must be 2\" .D} ?\n\n    .# rows\n    self.rows n.[1] #.>\n\n    .# cols\n    .# Pad the list with 0s\n    n.[0] .>\n    .# create empty list equal to the length of the last element\n    .# ex: cols=5 then create [0 0 0 0 0]\n    -1 dot_i E 0 \\L :d;\n    .# Replace 0s with the empty list\n    :# {$ 0 = {;d} ?}\n\n    self.M._new\n}\n\n\n.#? ::num ::matrix.pad\\n  insert N outer cols and rows of zeros\n.{ Example:\n    aya> 1 4R [2 2]L matrix!.pad\n    [[ 0 0 0 0 ]\n     [ 0 1 2 0 ]\n     [ 0 3 4 0 ]\n     [ 0 0 0 0 ]]\n.}\ndef matrix::pad {n::num self : r c,\n    self.r :r;\n    self.c :c;\n\n    self [r n + c n +] .<\n    [r n2* + c n2* +] .>\n}\n\n\n\n\n.#############\n.# Overloads #\n.#############\n\n.#? ::matrix U\\n  reverse the rows of a matrix\ndef matrix::__reverse__ {:& .rows U \\.M._new}\n\n.#? ::matrix E\\n  the shape of the matrix\ndef matrix::__len__ {.rows.E\\0IEJ}\n\n\n.#############\n.# Iteration #\n.#############\n\n\n.#? ::block ::matrix matrix.apply\\n  apply an expression to each element of the matrix in place\ndef matrix::apply {expr::block self,\n    self.rows # {#expr} self.:rows; self\n}\n\n.#? ::block ::matrix matrix.map\\n  apply an expression to each element of a matrix, return nothing\ndef matrix::map {expr::block self,\n    self.rows #{#expr};\n}:map;\n\n.#? ::matrix :# ::block \\n  make a copy of the matrix and apply an expression to each element\ndef matrix::__each__ {expr::block self,\n    self.rows$ :#{:#{expr}} self.M! \\;\n}\n\n\n\n.############\n.# Indexing #\n.############\n\n\n.# value row column matrix::_set\n.# Set the value of a location in a matrix\ndef matrix::_set {value r::num c::num self,\n    value self.rows.[r].:[c]; self\n}\n\n.#? matrix::cols\\n  return a copy of the matrix columns\ndef matrix::cols {.rows .T}\n\n.#? ::matrix [rows cols] I\\n get an item or a submatrix\ndef matrix::__getindex__ {ix mat : r c matrix^,\n    ix0I :r;\n    ix1I :c;\n\n    .# Get the data\n    mat.rows r I\n    r :T ::num = {A} ?\n    #{cI}\n\n    .# Transform the data based on input type\n    .# Return a new matrix if possible\n    c :T ::num = {\n        r :T ::num = {\n            .# `r` and `c` both nums, return a single item\n            0I\n        } {\n            .# Only columns returned, wrap each in a list\n            #A matrix!\n        } .?\n    } {\n        .# Only rows returned, convert to matrix\n        matrix!\n    } .?\n}\n\ndef matrix::__setindex__ {val ix self : r c matrix^,\n    {\n        (ix :T ::matrix =) {\n            val :T ::matrix = {val.rows :val;} ?\n            val :T ::list = {\n                val self.rows ix.rows [3|,D];\n            } {\n                self.rows ix.rows {val @@ D} .&;\n            } .?\n            self\n        } (ix :T ::list =) {\n            val ix.[0] ix.[1] self._set\n        } {\n            \"TypeError: Invalid operation $(other:T) $(self.T) *\" .D\n        }\n    } :?\n}\n\n.##############\n.# Generators #\n.##############\n\n.#? N matrix.eye\\n  generate an Nd identity matrix\ndef matrix::eye {matrix,\n    $0\\L1\\:J\\$:JL  matrix._new\n}\n\n.# generates the next row of a pascal matrix\ndef matrix::_nextpascal {prev::list matrix : new len ix,\n    prevE:len;\n    1 0 lenVL:J:new;\n    1:ix;\n    {prev ixI new ixVI+ new.:[ix]; ::ix B}lenV%\n    new\n}\n\n.#? I matrix.pascal\\n  generate an I by I matrix representation of pascal's triangle\n.{ Example:\n    aya> 4 matrix.pascal\n    [[ 1 1 1  1  ]\n     [ 1 2 3  4  ]\n     [ 1 3 6  10 ]\n     [ 1 4 10 20 ]]\n.}\ndef matrix::pascal {n::num matrix,\n    [1 n L {$matrix._nextpascal} n V %] matrix._new\n}\n\n.#? [rows cols] matrix::R\\n  generate a matrix counting up from 1\ndef matrix::__range__ {l::list matrix,\n    l~*R l L matrix!\n}\n\n.#? [rows cols] matrix.random\\n  create a N1 by N2 matrix of random values [0,1]\ndef matrix::__random__ {matrix,\n    0\\L :#{:#{;.Q}} matrix._new\n}\n\n.# rows::num cols::num matrix._newfill\\n  create a I1 by I2 matrix filled with N3\ndef matrix::_newfill {matrix, \\L\\Lmatrix._new}\n\n.#? [rows cols] matrix.ones\\n  create a N1 by N2 matrix of ones\ndef matrix::ones  {matrix, ~ 1 matrix._newfill}\n\n.#? [rows cols] matrix.zeros\\n  create a N1 by N2 matrix of zeros\ndef matrix::zeros {matrix, ~ 0 matrix._newfill}\n\n.#? value::num [rows cols] matrix.full\\n  create a rows x cols matrix filled with value\ndef matrix::full {value::num shape::list matrix,\n    shape.[0] shape.[1] value matrix._newfill\n}\n\n\n\n.#? ::matrix.comma_str\\n  print the matrix in list with comma format\ndef matrix::comma_str {.rows :#{ \",\" % \"[\" \\+\"]\"+} \",\" % \"[\"\\+ \"]\"+}\n","base/num.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metatable definition for the built-in `num` type\n\n:{\n\n    .#? ::num .digits\\n  convert a number into a list of digits\n    {\n        Z           .# Convert to bignum\n        .|          .# Absolute value (ignore negative)\n        P B;V;      .# Remove the ': and 'z\n        '. S V \\;   .# Remove any decimal\n        #:'         .# Convert to list of ascii values\n        48-         .# Subtract 48 (ascii value of '0)\n    }:digits;\n\n\n    .#? ::num .bits\\n  return binary representation of the integer\n    {.| 10 2 .&}:bits;\n\n    .#? ::num .bytes\\n  return byte list representation of the integer\n    {10 0 .&}:bytes;\n\n\n    .#? ::num .round\\n  round a decimal to the nearest whole value\n    {0.49999999-./}:round;\n\n\n    .#? ::num ::num.fixed\\n  round N1 to N2 decimal digits\n    {E$@@*.\\\\/}:fixed;\n\n\n    .#? n::nun lo::num hi::num .clip N1 between N2 (lo) and N3 (hi)\n    .# Reverse the order of min/max algorithms depending on sign\n    {@ .> .<}:clip;\n\n\n    .#? ::num.i\\n  generate a range from -N to N\n    .{ Example:\n        aya> 4.i\n        [ -4 -3 -2 -1 0 1 2 3 4 ]\n        aya> 1.i\n        [ -1 0 1 ]\n        aya> -1.i\n        [ 1 0 -1 ]\n    .}\n    {\n        $           .# dup n so we can use the sign later\n        .| $TR\\R    .# create negative and positive versions of the list\n        0\\:J:J        .# join lists with a 0 between\n        \\0<{U}?     .# If the sign is negative, reverse\n    }:i;\n\n\n    .#? ::num.frac\\n  the fractional part of the number\n    { 1:% }:frac;\n\n\n    .#? ::num.s\\n  split a decimal into two numbers\n    .{ Example:\n        aya> 4.6 .s\n        4 6\n        aya> 0.3 .s\n        0 3\n        aya> 5 .s\n        5 0\n    .}\n    {\n        $1:%P$.[0]'.={V;}?~ \\.\\ \\\n    }:fracsplit;\n\n}\n.# Merge with num metatable\n0 .M \\.+\n\n","std/date.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# date.aya\r\n.# Defines the date type\r\n\r\n.{? type: date\r\n    The date type provides operations for accessing date and time variables.\r\n.}\r\n\r\n:{\r\n\r\n    ::date :__type__;\r\n    1 :__pushself__;\r\n\r\n    {:{M$:ms} date :M}:now;\r\n\r\n    .# {in meta, [\r\n    .#     in:T ::num = {:{in:ms} meta :M} ?\r\n    .#     in:T ::str = {:{in \"yyyy-MM-dd\" :(date.parse):ms} meta :M} ?\r\n    .#     {\"Expected S|D, recieved: $in\".D}\r\n    .# ].S }:__new__;\r\n\r\n    {in meta,\r\n        {\r\n            (in :T ::num =) {\r\n                :{ \r\n                    in:ms\r\n                } meta :M\r\n            } (in :T ::str =) {\r\n                :{ \r\n                    in \"yyyy-MM-dd\" :(date.parse) :ms;\r\n                } meta :M\r\n            } {\r\n                \"Expected ::str or ::num. recieved: $in\" .D\r\n            }\r\n        } :?\r\n    }:__new__;\r\n\r\n    {.ms \"MMM dd, yyyy h:mm:ss a\" :(date.format)}:__repr__;\r\n    {.__repr__}:__str__;\r\n\r\n    {.ms :(date.desc).day_of_week}:dayofweekid;\r\n    {.ms :(date.desc).day_of_week dates.weekdays\\V I}:dayofweek;\r\n    {.ms :(date.desc).day_of_week dates.weekdaysabb\\V I}:dayofweekabb;\r\n    {.ms :(date.desc).year}:year;\r\n    {.ms :(date.desc).month}:monthid;\r\n    {.ms :(date.desc).month dates.monthnames\\I}:month;\r\n    {.ms :(date.desc).month dates.monthsabb\\I}:monthabb;\r\n    {.ms :(date.desc).day_of_month}:dayofmonth;\r\n    {.ms :(date.desc).hour}:hour:h;\r\n    {.ms :(date.desc).minute}:min:m;\r\n    {.ms :(date.desc).second}:sec:s;\r\n    {.ms\"a\":(date.format)}:ampm;\r\n\r\n    {self unit,\r\n        self.ms unit.ms + date!\r\n    }:__radd__;\r\n\r\n    {self unit,\r\n        self.ms unit.ms - date!\r\n    }:__rsub__;\r\n\r\n    {.ms}:__sort__;\r\n\r\n    .# Parse Functions\r\n    {\"MM/dd/yy\" :(date.parse)}:parsemdy;\r\n\r\n    .# String functions\r\n    {.ms \"MM/dd/yy\"   :(date.format)}:mmddyy;\r\n    {.ms \"MM/dd/yyyy\" :(date.format)}:mmddyyyy;\r\n    {.ms \"hh:mm aa\"   :(date.format)}:timestr;\r\n\r\n}:date;\r\n\r\n.#? dateunit\\n  static namespace defining units related to dates\r\n:{\r\n    [\r\n        [\"year\" 31536000000]\r\n        [\"month\" 2628000000]\r\n        [\"week\" 604800000]\r\n        [\"day\" 86400000]\r\n        [\"hour\" 3600000]\r\n        [\"minute\" 60000]\r\n        [\"second\" 1000]\r\n    ]:units;\r\n\r\n    units # {u : name conv,\r\n        u0I:name;\r\n        u1I:conv;\r\n        :{\r\n            1 :__pushself__;\r\n            {n::num meta, :{n:n} meta :M}:__new__;\r\n            {.n x +} :{ \" dates.$name\":x} .+ :__repr__;\r\n            {.n conv*}.use[::conv]:ms;\r\n            {date.__radd__.`~}:__add__;\r\n            {date.__rsub__.`~}:__sub__;\r\n        } name:S := ;\r\n    };\r\n}:dateunit;\r\n\r\n.#? dates\\n  static namespace for date related variables\r\n:{\r\n    .# Units\r\n    dateunit.units # {u : name,\r\n        u0I:name;\r\n        \"{:dateunit^,dateunit.$name!}:$name\"~\r\n    };\r\n\r\n    .# Week Day Names\r\n    [\r\n        \"Sunday\" \"Monday\" \"Tuesday\" \"Wednesday\"\r\n        \"Thursday\" \"Friday\" \"Saturday\"\r\n    ]:weekdays;\r\n    [\"Sun\" \"Mon\" \"Tue\" \"Wed\" \"Thr\" \"Fri\" \"Sat\"]:weekdaysabb;\r\n\r\n    .# Month Names\r\n    [\r\n        \"January\" \"February\" \"March\" \"April\"\r\n        \"May\" \"June\" \"July\" \"August\"\r\n        \"September\" \"October\" \"November\" \"December\"\r\n    ]:monthnames;\r\n\r\n    [\r\n        \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\"\r\n        \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\r\n    ]:monthsabb;\r\n\r\n}:dates;\r\n","std/dialog.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# dialog.aya\r\n.# Interface to the dialog operator :(dialog.legacy)\r\n\r\n.{? dialog\r\n    various dialogs and windows\r\n    all functions in this module are shortcuts for the :(dialog.legacy) operator\r\n.}\r\n\r\n.#? ::str dialog.requeststr\\n  request a string from the user\r\ndef ::getstr {question,\r\n    question :(dialog.getstr)\r\n}\r\n\r\n.#? ::str dialog.requestnum\\n  request a number from the user\r\ndef ::getnum {question,\r\n    question :(dialog.getnum)\r\n}\r\n\r\n.#? ::str dialog.alert\\n  display a dialog box with a given message\r\ndef ::alert {text,\r\n    text \"Aya\" ::plain :(dialog.alert)\r\n}\r\n\r\n.#? ::str dialog.warning\\n  display a warning message with the given message\r\ndef ::warning {text,\r\n    text \"Aya\" ::warn :(dialog.alert)\r\n}\r\n\r\n.#? ::str dialog.error\\n  display an error message with the given message\r\ndef ::error {text,\r\n    text \"Aya\" ::error :(dialog.alert)\r\n}\r\n\r\n.#? ::str dialog.warn\\n  display a warning message with the given message\r\ndef ::warn {text,\r\n    text \"Aya\" ::warn :(dialog.alert)\r\n}\r\n\r\n.#? ::str ::str ::str dialog.yesno\\n  display a dialog box with the question ::str1. ::str2 and ::str3 return true and false respectively\r\ndef ::yesno {question yes no,\r\n    question [yes no] \"Aya\" ::plain :(dialog.confirm)\r\n}\r\n\r\n.#? message::str dialog.confirm\\n  Return 1 if the user presses okay and 0 otherwise\r\ndef ::confirm {question,\r\n    question [\"Okay\" \"Cancel\"] \"Aya\" ::plain :(dialog.confirm)\r\n}\r\n\r\n.#? ::str ::list dialog.buttons\\n  display a dialog box with buttons for each of the options in L. Returns the item in the list as a string.\r\ndef ::buttons {question options::list,\r\n    question options \"Aya\" ::question :(dialog.buttons)\r\n}\r\n\r\n.#? ::str ::list dialog.dropdown\\n  display a dialog box with a dropdown selection of the options in L\r\ndef ::dropdown {question options::list,\r\n    question options \"Aya\" ::question :(dialog.dropdown)\r\n}\r\n\r\n.#? dialog.choosefile\\n  open a file selection window. return the full path of the selected file\r\ndef ::choosefile {\r\n    :(dialog.choosefile)\r\n}\r\n","std/terminal.aya":"require color {color colors}\n\n:{\n    colors.white :fg;\n    colors.black :bg;\n}:term_state;\n\ndef ::clear {\"\\{x1b}[2J\".P}\ndef ::clearline {\"\\{x1b}[1:J\\{x1b}[1G\".P}\n\ndef ::_setfgstr {c::color, \"\\{x1b}[38;2;$(c.r);$(c.g);$(c.b)m\" }\ndef ::_setbgstr {c::color, \"\\{x1b}[48;2;$(c.r);$(c.g);$(c.b)m\" }\n\ndef ::setfg {c::color : term_state^ _setfgstr^,\n    c term_state.:fg;\n    c _setfgstr .P\n}\n\ndef ::setbg {c::color : term_state^ _setbgstr^,\n    c term_state.:bg;\n    c _setbgstr .P\n}\n\ndef ::bold      { \"\\{x1b}[1m\" \"\\{x1b}[22m\" .? .P}\ndef ::italic    { \"\\{x1b}[3m\" \"\\{x1b}[23m\" .? .P}\ndef ::underline { \"\\{x1b}[4m\" \"\\{x1b}[24m\" .? .P}\ndef ::strike    { \"\\{x1b}[9m\" \"\\{x1b}[29m\" .? .P}\n\ndef ::reset_font {: bold^ italic^ underline^ strike^ ,\n    0 bold\n    0 italic\n    0 underline\n    0 strike\n}\n\ndef ::reset_color {: colors^ setfg^ setbg^ ,\n    colors.white setfg\n    colors.black setbg\n}\n\ndef ::replcolor {c::color : colors^ _setfgstr^ ,\n    [c _setfgstr\n     \"aya> \"\n     colors.white _setfgstr]W\n    :(sys.alterprompt)\n}\n\ndef ::print_color {value c::color : term_state^ setfg^ prev_fg,\n    term_state.fg :prev_fg;\n    c setfg\n    value P .P\n    prev_fg setfg\n}\n\ndef ::println_color {value c::color : print_color^,\n    value c print_color\n    \"\" :P\n}\n","std/la.aya":".# This file is a part of Aya: https://github.com/aya-lang/aya\n\n.# la.aya\n.# Defines linear algebra functions\n\n.# Wrapper functions\n{:(la.mul)}:dot;\n","std/docs.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\r\n\r\n.# docs.aya\r\n.# Basic documentation for Aya that appears in the quicksearch\r\n\r\n.{? docs: comments\r\n   .# this is a line comment\r\n   .{\r\n     this is a block comment\r\n   .\\}\r\n\r\n   .#? this line will be added to interactive help\r\n   .{?\r\n      these lines will be\r\n      added to interactive help\r\n   .\\}\r\n.}\r\n\r\n.{? docs: argument type key\r\n  ::num - num\r\n  ::block - block\r\n  ::char - character\r\n  ::str - string\r\n  ::any - any\r\n  ::dict - dict\r\n  ::sym - symbol\r\n.}\r\n\r\n.{? docs: ranges\r\n  ranges are used in list comprehension notation for creating quick lists\r\n  they can be built from all number types, characters, strings, and list literals\r\n  examples:\r\n   [2,] => [1 2]\r\n   [2 5,] => [2 3 4 5]\r\n   [0 2 6,] => [0 2 4 6]\r\n   ['a 'c,] => [a b c]\r\n   [\\\"hi\\\",] => [h i]\r\n   [[1 2],] => [1 2]\r\n.}\r\n\r\n.{? docs: list comprehension\r\n  a range is always required. map and filter blocks are not.\r\n\r\n  syntax:\r\n  [\r\n    <range>,\r\n    <map>,\r\n    <filter1>,<filter2>,..<filterN>\r\n  ]\r\n.}\r\n\r\n.{? docs: blocks\r\n  blocks are containers for a group of operations and a list of arguments.\r\n  syntax:\r\n    {<expr>}\r\n    {<args> , <expr>}\r\n    {<args> : <locals> , <expr>}\r\n    {: <locals> , <expr>}\r\n.}\r\n\r\n.{? docs: dictionaries\r\n  dicts are created using the following syntax\r\n  :{ val1:key1 val2:key2 ... valN:keyN}\r\n.}\r\n\r\n.{? docs: special characters\r\n  unicode: '\\U263A' => \\{U263A}\r\n  named:   '\\in' => \\{in}\r\n  strings: \"I \\\\{heart} element\" => \"I \\{heart} element\"\r\n.}\r\n\r\n.{? docs: negative numbers\r\n  use :<number> or :-<number> for number literals only\r\n  use the (T) operator to negate a variable\r\n.}\r\n\r\n.{? docs: list grabbing\r\n  List literals can grab items from the outer stack\r\n  Use the format `... [num| ...]` where `num` is an num literal\r\n  ex: 1 2 [1| 7 6] => 1 [2 7 6]\r\n  ex: 4 [1|10,] => [4 5 6 7 8 9 10]\r\n.}\r\n\r\n.{? docs: constants\r\n  use `:Nc` where N is:\r\n  0: pi\r\n  1: e\r\n  2: double max\r\n  3: double min\r\n  4: NaN\r\n  5: +inf\r\n  6: -inf\r\n  7: int max\r\n  8: int min\r\n  9: system file separator\r\n  10: system path separator\r\n  11: char max value\r\n  12: system line separator\r\n.}\r\n","std/mp.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metaprogramming utilities\n\n.#? ::list mp.merge\\n  Convert a list of blocks into a single block\ndef ::merge {\n    #.op .*\n}\n\n\n\n","base/char.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metatable definition for the built-in `char` type\n\n:{\n    .#? C.islower\\n  tests if a character is lowercase\n    {$ 'a :> \\ 'z :< &}:islower;\n\n    .#? C.isupper\\n  tests if a character is uppercase\n    {$ 'A :> \\ 'Z :< &}:isupper;\n\n    .#? C.toupper\\n  converts a character to uppercase\n    {$.isupper! {!} ? }:upper;\n\n    .#? C.tolower\\n  converts a character to lowercase\n    {$.islower! {!} ? }:lower;\n\n    .#? C.isdigit\\n  tests if a character is a digit\n    {$ '0 :> \\ '9 :< &}:isdigit;\n\n    .#? C.iswhitespace\\n  tests if a character is a whitespace character\n    { \" \\f\\n\\r\\t\\v\\{x00A0}\\{x2028}\\{x2029}\" \\ H}:iswhitespace;\n\n    .#? C.isascii\\n  test if character is ascii\n    {:' 127 <}:isascii;\n\n    .#? C.isalpha\\n  test if character is alphabetical\n    {$ $ 'a :> \\ 'z :< & \\ $ 'A :> \\ 'Z :< & |}:isalpha;\n\n    .#? ::str ::char .split_keep\\n  split the string at the char, keep the char in the leading string\n    {s c,\n        s c S #{c+} \n\n        .# If c is not the last char of s,\n        .# remove c from the last item of the list\n        s.[-1]c=! {\n            :&.[-1]B;\\.:[-1]\n        } ? \n        \n    }:split_keep;\n}\n.# Merge with char metatable\n'x .M \\.+\n","std/shell.aya":"import sys\nimport terminal\nrequire io {path}\n\n.# Shell-like commands for Aya\n\nstruct shellresult {value}\n\ndef shellresult::__repr__ {self,\n    self.value\n}\n\ndef shellresult::lines {self,\n    self.value '\\n' S\n}\n\n\n:{} :shell_impl;\n\ndef shell_impl::grep {res::shellresult rgx::str : shellresult^ ,\n    res.lines {rgx &E0>} I\n    \"\\n\" % shellresult!\n}\n\ndef shell_impl::cat {filename::str : shellresult^ ,\n    filename G shellresult!\n}\n\ndef shell_impl::echo {data::str : shellresult^ ,\n    data shellresult!\n}\n\n\n.#? ls\\n  print a list of files in the working dir\ndef ::ls {: shellresult^ ,\n    :(sys.wd) :(sys.readdir)\n    .E 0 = {\n        ; \"  <no files>\"\n    } {\n        C \"\\n\" %\n    } .?\n\n    shellresult!\n}\n\n\n.#? pwd\\n  print working directory\ndef ::pwd {: path^ , path.working:P}\n\n\n.#? cd dir\\n  change directory\ndef ::cd {{sys.cd} 0:`}\n\n\n.#? mkdir S\\n  create a new directory\ndef ::mkdir { {sys.mkdir} 0 :` }\n\n\n.# def ::echo ({(4 hold)x (2 hold)~} :{ shell_impl.echo.` :x } .+)\n\n.#? echo S\\n  print a string to the console\ndef ::echo {: shell_impl^,  \n    {: shell_impl^, ~ shell_impl.echo } 0 :`\n}\n\n.#? cat S\\n  print a file to the console\ndef ::cat {: shell_impl^, \n    {: shell_impl^, ~ shell_impl.cat} 0 :`\n}\n\ndef ::grep {: shell_impl^, \n    {: shell_impl^, ~ shell_impl.grep} 0 :`\n}\n\n\ndef ::touch { {s::str, \"\" s 1.G} 0 :` }\n\ndef ::clear {:terminal^, terminal.clear}\n\n\ndef (__aya__.interpreter)::shell {str : cmd args,\n    str ' N $ 0 :> {\n        ;; str~\n    } {\n        Mu trim :args; :cmd;\n        cmd~ args\n    } .?\n}\n","std/pkg.aya":"import json\n\n\"\"\"\n# pkg\n\nPackage manager for aya\n\n## REPL API\n\n  - `name pkg.add`: Add a package\n    - `name` can be a zip URL or a github repo stub \"username/package\"\n  - `\"package\" pkg.test\"`: Run tests for an installed package\n  - `\"package\" pkg.run\"`: Run package.__run__ if the package defines it\n  - `\"package\" pkg.metadata`: Get metadata (package.json) for a package\n  - `pkg.list`: Print installed packages\n    - `pkg._list_package_metadata` to get dict of all package metadata\n\n\"\"\";\n\n\n.#\n.# Logging\n.#\n\n.# Set enabled to true if you want debug logging\n:{ 1 :enabled; }:_debug_mode;\n\n{msg::str : _debug_mode^,\n    _debug_mode.enabled {\n        \"[DEBUG/pkg]: $msg\" :P\n    } ?\n} :_log_debug;\n\n.#\n.# HELPER FUNCTIONS\n.#\n\n.# Get root package directory\n.# <aya_dir>/pkg\n{\n    :(sys.ad) \"pkg\" :(sys.joinpath) :(sys.abspath)\n} :get_pkg_dir;\n\n\n.# pkg/source.json stores a mapping of package names to zip URLs\n{:get_pkg_dir^ json^,\n    get_pkg_dir \"source.json\" :(sys.joinpath) local :json_path;\n    {\n        json_path G\n    } {;\n        \"{}\"\n    } .K\n\n    json.loads\n} :_load_source_data;\n\n\n{data : get_pkg_dir^ json^,\n    .# data\n    data json.dumps\n    .# path\n    get_pkg_dir \"source.json\" :(sys.joinpath) \n    .# write\n    0.G\n} :_save_source_data;\n\n\n.# stub: username/pkgname\n.# Get the zip url for this package\n{stub::str : json^ _log_debug^,\n    .# Fetch repo data so we can determine the default branch\n    \"https://api.github.com/repos/$stub\" G json.loads local :repo_data;\n    repo_data.default_branch local :branch;\n\n    .# Zip file URL\n    \"https://github.com/$stub/archive/refs/heads/$branch.zip\"\n} :_get_github_zip_url;\n\n\n.# Return a dict of metadata for all installed packages\n.# returns :{ <metadata> :<package_name> }\n{: get_pkg_dir^ json^ p,\n\n    get_pkg_dir :p :(sys.readdir) :# {dir,\n        p dir :(sys.joinpath) :dir;\n        dir :(sys.isdir) {\n            dir \"package.json\" :(sys.joinpath) G json.loads\n        } ?\n    } local :all_packages;\n    :{ [all_packages, :& .name :=];}\n} :_list_package_metadata;\n\n\n{zip_url::str allow_replace : \n    _log_debug^ json^ get_pkg_dir^\n    _save_source_data^ _load_source_data^,\n\n    \"pkg._install\" _log_debug\n    get_pkg_dir local :aya_pkg_dir;\n    \"Using pkg root dir $aya_pkg_dir\" _log_debug\n    aya_pkg_dir :(sys.mkdir)\n\n    aya_pkg_dir \"tmp.zip\" :(sys.joinpath) local :zip_path;\n    \"Downloading file: $zip_url to $zip_path\" _log_debug\n    zip_url zip_path :(download.to_file)\n\n\n    .# Unzip\n    aya_pkg_dir \"tmp\" :(sys.joinpath) local :unzip_loc;\n    \"Unzipping $unzip_loc\" _log_debug\n    zip_path unzip_loc :(sys.unzip)\n\n    .# Get the location of the package in the unzipped folder\n    unzip_loc $ :(sys.readdir).[0] :(sys.joinpath) local :tmp_pkg_dir;\n    \"Location of unzipped package: $tmp_pkg_dir\" _log_debug\n\n    .# Load the package data\n    tmp_pkg_dir \"package.json\" :(sys.joinpath) G json.loads local :pkg_data;\n    \"Got package data $pkg_data\" _log_debug\n\n    aya_pkg_dir pkg_data.name :(sys.joinpath) local :install_pkg_dir;\n\n    1 local :do_install;\n    .# If we are not allowed to replace, we must first check to see if it is empty\n    allow_replace ! {\n        install_pkg_dir :(sys.isdir) {\n            \"Package '$(pkg_data.name)' already exists, skipping install. Use pkg.update to update an existing package or pkg.remove to remove old package if you would like to install this one\" :P\n            0 :do_install;\n        } ?\n    } ?\n\n    do_install {\n        .# If there is a package here already, remove it\n        install_pkg_dir :(sys.isdir) { install_pkg_dir :(sys.rm) } ?\n\n        \"Moving files from $tmp_pkg_dir to $install_pkg_dir\" _log_debug\n        tmp_pkg_dir install_pkg_dir :(sys.mvdir)\n\n        .# Update installed packages json\n        zip_url _load_source_data.:[pkg_data.name] _save_source_data\n    } ?\n\n    \"Cleaning up...\" _log_debug\n    zip_path :(sys.rm)\n    unzip_loc :9s + :(sys.rm)\n} :_install;\n\n\n.#\n.# REPL API\n.#\n\n{id::str :\n    _install^ _get_github_zip_url^\n    allow_replace(0),\n\n    id \".zip\" H {\n        id allow_replace _install\n    } {\n        .# If it isn't a zip url, assume it is a github one\n        id _get_github_zip_url allow_replace _install\n    } .?\n} :add;\n\n\n{name::str :\n    _install^ _list_package_metadata^ _load_source_data^\n    allow_replace(1),\n\n    _list_package_metadata local :md;\n    md name H {\n        .# Get the URL to the zip file\n        _load_source_data.[name]\n        .# Install with allow_replace set to true\n        allow_replace _install\n    } {\n        \"Package $name does not exist. You can install it with pkg.add\" .D\n    } .?\n} :update;\n\n\n{name::str : get_pkg_dir^ test_dir,\n    get_pkg_dir name :(sys.joinpath) \"test\" :(sys.joinpath) :test_dir;\n\n    test_dir :(sys.isdir) {\n        test_dir :(sys.readdir) :# {fname,\n            fname \".aya\" H {\n                :{ .# open new scope\n                    [test_dir :9s fname] W \n                    $ \"Running test: \" \\+ :P\n                    :F\n                };\n            } ?\n        };\n    } {\n        \"Package $name does not have a test directory\" :P\n    } .?\n} :test;\n\n\n{name::str : get_pkg_dir^ json^,\n    get_pkg_dir name :(sys.joinpath) \"package.json\" :(sys.joinpath) G json.loads\n} :metadata;\n\n\n{name::str,\n    :{ .# open a new scope\n        name [::__run__] __aya__.importlib.require\n\n        __run__\n    };\n} :run;\n\n\n{name::str :\n    _list_package_metadata^ get_pkg_dir^\n    _load_source_data^ _save_source_data^,\n\n    _list_package_metadata local :md;\n    md name H {\n        _load_source_data name .- _save_source_data\n        get_pkg_dir name :(sys.joinpath) :(sys.rm)\n    } {\n        \"Package $name does not exist. Nothing to remove\" :P\n    } .?\n} :remove;\n\n\n{: _list_package_metadata^,\n    _list_package_metadata :# {_ data,\n        \"$(data.name) v$(data.version) ($(data.author))\" :P\n    };\n} :list;\n","std/sys.aya":"require io {path}\n\n:{} :sys;\n\ndef ::args :(sys.args)\n\n\n.#? sys.iswindows\\n  returns true if system is windows\ndef ::iswindows {:9s\"\\\\\"=}\n\n\n.# ::str sys.cd\\n  set working directory\ndef ::cd {dirname : path^,\n    dirname\n    .# If it is a string, conv to path\n    dirname :T ::str = { path! } ?\n    P :(sys.cd)\n}\n\n\n.#? ::str sys.mkdir\\n  create a new directory\ndef ::mkdir {dir,\n    dir P :(sys.mkdir)\n}\n\n\ndef ::readdir {dir,\n    dir P :dir;\n    dir \"\" = {\".\" :dir;} ?\n    dir :(sys.readdir)\n}\n\n","std/rdatasets.aya":"import csv\n\n:{} :rdatasets;\n\ndef rdatasets::_index_csv \"https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/datasets.csv\"\ndef rdatasets::_cache_loc \"rdatasets_index.csv\"\n\n.# Load index file\ndef rdatasets::load_index {:index_str(\"\") data index(:{}) packages(:{}),\n\n    {\n        rdatasets._cache_loc G :index_str;\n    } {\n        \"Downloading dataset from $(rdatasets._index_csv)...\" :P\n        rdatasets._index_csv G :index_str;\n        index_str rdatasets._cache_loc 0 .G\n    } .K\n\n    \"Parsing CSV...\" :P\n    index_str \",\" csv.parse :data;\n    data V; :data; .# Remove first row\n\n    data :d;\n\n    .# Build index\n    \"Building index...\" :P\n    data :# {row : pkg(row.[0]) name(row.[1]),\n        .# Add to url index\n        row.[-2] index.:[\"$pkg/$name\"]\n\n        .# Add to package index\n        .# Add package list if it does not exist\n        packages pkg H ! { [] packages.:[pkg]; } ?\n        .# Add name to list\n        name packages.[pkg] .B ;\n\n    };\n    \"Done.\" :P\n\n    def rdatasets::index index\n    def rdatasets::packages packages\n}\n\n\ndef rdatasets::index :{}\ndef rdatasets::packages :{}\n\ndef rdatasets::load {id::str : rdatasets^ csv^,\n    rdatasets.index :E 0 = {\n        rdatasets.load_index\n    } ?\n    \n    \"/\" id.in {\n        rdatasets.index.[id]\n    } {\n        rdatasets.index.[\"datasets/$id\"]\n    } .?\n\n    csv.open\n}\n\n\nrdatasets:r;\n\n\n\n\n","base/block.aya":":{\n\n    .# Functional Operations\n    .########################\n\n    .#? ::list ::list ::block.pu\\n  (permusing) permutes elements of two lists and applies an expression to each\n    .{ Example:\n        aya> \"AB\" \"ab\" {P+}.pu\n        [[\"Aa\" \"Ab\"][\"Ba\" \"Bb\"]]\n        aya> [1 2 3][4 5 6] {P+}.pu\n        [[4 5 6][8 10 12][12 15 18]]\n    .}\n    {la lb ex, [lb la lbEL,\\#{ex}]}:pu;\n\n\n    .#? ::list ::block.tw\\n  (takewhile) take from list while the condition is satisfied\n    .{ Example:\n        aya> 10R {5<}.tw\n        [ 1 2 3 4 ]\n    .}\n    {e,{e!}.N $0= {;;[]} {S~;} .? }:tw;\n\n\n    .#? ::any ::list ::block.el\\n  apply block to `any` and `i` for each element across list\n    .{ Example:\n        aya> \"a\" [\"A\" \"B\" \"C\"] {+}.el\n        [\"aA\" \"aB\" \"aC\"]\n    .}\n    {@@.E@\\L\\@.&}:el;\n\n\n    .#? ::list ::any ::block.le\\n  apply block to `any` and `i` for each element across list\n    .{ Example:\n        aya> [\"A\" \"B\" \"C\"] \"a\" {+}.le\n        [\"Aa\" \"Ba\" \"Ca\"]\n    .}\n    {@@\\.E@\\L@.&}:le;\n\n\n    .#? ::block.haslocals\\n  return true if the block has a local variables\n    .# Both the args and the locals mush be empty for this to be false\n    {.| :&.locals:E \\.argsE + 0 =!}:haslocals;\n\n\n    .#? ::block.locals\\n  get the locals of a block\\n  will throw error if block does not have locals\n    {.|.locals}:locals;\n\n\n    .#? ::block.args\\n  get an ordered list of argument descriptions to the block\\n  empty list if there are none\n    {.|.args}:args;\n\n    .#? ::block .use ::list\\n  evaulate the variables (given by a list of symbols) in the block in the current scope\n    .{ Example:\n        aya> 2:y\n        2\n        aya> {x, x y *}.use[::y] :double\n        {x , x 2 * }\n        aya> 3 double\n        6\n    .}\n    {(1 hold)({:d__,\n        .# Create a dictionary of all values given by the list\n        :{}:d__;\n        :#{$~\\d__:D;};\n        .# Substitute the values from the dictionary into the block\n        d__ .+\n    })}:use;\n\n    .#? ::block .time\\n  return the result of the block and the execution time in ms\n    {:a__, M$:a__; ~ M$ a__ -} :time;\n\n    .# Utility Functions\n    .#####################\n\n    .#? ::block .op\\n  return the block (allows use of (::sym or ::block) .op without type checking\n    {}:op;\n\n}\n.# Merge with char metatable\n{} .M \\.+\n\n.# Define operators\n{.le}:otimes;\n{.el}:odot;\n","base/list.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\r\n\r\n.# Metatable definition for the built-in `list` type\r\n\r\n:{\r\n    .# Querying\r\n    .###############\r\n\r\n    .#? ::any ::list .in\\n  tests whether or not item is in the list\r\n    {\\H}:in;\r\n\r\n    .#? ::list .max\\n  max value of a list\r\n    {{.<}%}:max;\r\n\r\n    .#? ::list .min\\n  min value of a list\r\n    {{.>}%}:min;\r\n\r\n    .#? ::list .argmax\\n  return the index of the largest value in the list\r\n    {$.maxN\\;}:argmax;\r\n\r\n    .#? ::list .argmin\\n  return the index of the smallest value in the list\r\n    {$.minN\\;}:argmin;\r\n\r\n    .#? ::list ::list .i\\n  index using mask\r\n    {.ER*{0=!}I1#- .E0={;;[]} {.E@@I\\ 1={A}?} .?}:i;\r\n\r\n    .#? ::list ::list.mask\\n  select indices with non-false values from list\r\n    .{\r\n        aya> [1 2 3 4 5] [0 1 0 0 1].mask\r\n        [ 2 5 ]\r\n    .}\r\n    {a b,\r\n        aE bE = {\r\n            a b .E R * .[{0=!}] 1- I\r\n        } {\r\n            \"::list.mask: both lists must be the same length\" .D\r\n        } .?\r\n    }:mask;\r\n\r\n    .#? ::list.alleq\\n  return true if all items in the list are the same\r\n    {:~E1:<}:alleq;\r\n\r\n    .#? ::list .allt\\n  true if all elements in list are true\r\n    {{&}%}:allt;\r\n\r\n    .#? ::list .allf\\n  true if all elements in list are false\r\n    {{|}%!}:allf;\r\n\r\n    .# Convenience functions for using a list as a vector\r\n    {.[0]}:x;\r\n    {.[1]}:y;\r\n    {.[2]}:z;\r\n    {.:[0]}:setx;\r\n    {.:[1]}:sety;\r\n    {.:[2]}:setz;\r\n\r\n\r\n    .# Manipulation\r\n    .###############\r\n\r\n\r\n    .#? ::any ::list .append\\n  add item to end of list\r\n    {.B}:append;\r\n\r\n    .#? ::list .pop\\n  remove item from end of list\r\n    {B}:pop;\r\n\r\n    .#? ::list .roll\\n  move the last element to the front\r\n    {B\\.V}:roll;\r\n\r\n    .#? ::num ::list .rotate\\n  shift items in list up N times wrappping the items around\r\n    .{ Example:\r\n        aya> 1 [1 2 3 4].rotate\r\n        [ 4 1 2 3 ]\r\n        aya> 2 [1 2 3 4].rotate\r\n        [ 3 4 1 2 ]\r\n        aya> -1 [1 2 3 4].rotate\r\n        [ 2 3 4 1 ]\r\n    .}\r\n    {\r\n        .E@-        .# inverse so rotate in correct direction 2 5R => 3\r\n        \\.E@\\:%     .# force bounds: n % length\r\n        S ~ \\ :J    .# Split, swap, and rejoin\r\n    }:rotate;\r\n\r\n\r\n    .#? ::num ::num ::list .swap\\n  swap two elements in a list given their indices\r\n    {i::num j::num l::list: tmp,\r\n        l i I : tmp;\r\n        l j I  l i D;\r\n        tmp l j D\r\n    }:swap;\r\n\r\n\r\n    .#? ::list .shuffle\\n  shuffle a list\r\n    {{;.Q}.C}:shuffle;\r\n\r\n\r\n    .#? ::list .makesquare\\n  make all lists in the given 2d lists the same length\r\n    {list,\r\n        list$ #E {.<} %\r\n        #.<\r\n    }:makesquare;\r\n\r\n\r\n    .# Generators\r\n    .#############\r\n\r\n    .#? ::list.r\\n  multidimentional range\r\n    .{ Example:\r\n        aya> [2 3].r\r\n        [ [ 1 2 3 ] [ 4 5 6 ] ]\r\n    .}\r\n    {${*}%R\\L}:r;\r\n\r\n    .#? ::list.zeros\\n  generate a [N1 x N2 x ...] list of zeros\r\n    .#? ::list.ones\\n  generate a [N1 x N2 x ...] list of ones\r\n    .{? Example:\r\n        aya> [2 3].zeros\r\n        [ [ 0 0 0 ] [ 0 0 0 ] ]\r\n        aya> [4].ones\r\n        [ 1 1 1 1 ]\r\n    .}\r\n    {${*}%0\\L\\L}:zeros;\r\n    {${*}%1\\L\\L}:ones;\r\n\r\n    .#? ::any ::num ::list .lpad\\n  left pad list using ::any to a max length of ::num\r\n    { .E @ \\- 0.< @\\L\\J }:lpad;\r\n    .#? ::any ::num ::list .rpad\\n  left pad list using ::any to a max length of ::num\r\n    { .E @ \\- 0.< @\\L J }:rpad;\r\n\r\n    .#? ::list ::num .pad\\n 2d padding\r\n    {n l, l:En+$n+\\~ l\\#.>\\.> \\~@ \\#.<\\.<}:pad;\r\n\r\n\r\n    .#? ::any ::list .surround\\n  append A to the front and back of L\r\n    {$\\; \\$@J\\J}:surround;\r\n\r\n    .#? ::list .enumerate\\n  return a list of index-value pairs for the list\r\n    {.E.R{A.B}.&}:enumerate;\r\n\r\n    .#? ::list .rank\\n  rank a list from highest to lowest\r\n    {${>}.pu#W1+}:rank;\r\n\r\n    .#? ::list .irange\\n generates a range of indices for the list\r\n    {E.R}:irange;\r\n\r\n\r\n\r\n    .# OTHER UTILITIES\r\n    .##################\r\n\r\n    .#? ::list.dict_flatten\\n  given a list of dicts, flatten the into a single dict\r\n    {\r\n        :{}\\J{.+}%\r\n    }:dict_flatten;\r\n\r\n\r\n    .#? ::list .matstr\\n  convert a 2d list into a string with evenly spaced columns\r\n    .{ Example:\r\n        aya> [[\"A\" \"B\" \"CCC\"][\"D\" \"EE\" \"F\"]] .matstr :P\r\n        A B  CCC\r\n        D EE F\r\n        aya> [[\"A\" pi \"CCC\"][\"hello world\" \"EE\" 2]] .matstr :P\r\n        A           3.14159265 CCC\r\n        hello world EE         2  \r\n    .}\r\n    def ::matstr {m : colmax,\r\n        m :#{#{PE}}.T:#{{.<}%}:colmax;      .# The max width for each column\r\n        m .T colmax {#{\\P\\ B.<}} .& .T      .# For each colum, convert to string with\r\n                                            .# padding equal to the max for that column + 1\r\n        :#{WB;}                             .# Combine each row into a single string, remove trailing space\r\n        '\\n' %                              .# Join with newlines\r\n    }\r\n\r\n    {\\.S}:rotate_rows;\r\n    {\\0\\J.S}:rotate_cols;\r\n}\r\n.# Merge with list metatable\r\n[] .M \\.+\r\n\r\n\r\n.# Removing .I, can directly swap for this\r\n{\\:&@I}:dot_i;\r\n","base/__aya__.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\r\n\r\n\r\n.# __aya__\r\n.# Defines the __aya__ namespace and keywords\r\n\r\n.# NOTE: 12 letter variables ending in the letter 'z' are reserved for use in\r\n.#       standard library. Such variables are used below.\r\n\r\n{:(sys.ad) \"test/test.aya\" + :F}:tt;\r\n\r\n.# Global __aya__ table\r\n:{\r\n\r\n    :{}:interpreter;\r\n\r\n    .# If set to 1, all breakpoints will be ignored\r\n    .#? __aya__.ignore_breakpoints\\n  if true, skip all breakpoints\r\n    0 :ignore_breakpoints;\r\n\r\n}:__aya__;\r\n\r\n:{\r\n    :{ \r\n        ::__nil :__type__;\r\n        \"nil\" :__str__;\r\n        \"nil\" :__repr__'\r\n        1 :__pushself__;\r\n        {:T ::__nil =}:__eq__;\r\n    }:__meta__;\r\n}:nil;\r\n\r\n.#######################################\r\n.# DEFINE __aya__ KEYWORDS AND GLOBALS #\r\n.#######################################\r\n\r\n.# -----\r\n.# DEBUG\r\n.# -----\r\n\r\n.#? bp\\n  set a breakpoint\r\n{ : __aya__^,\r\n    __aya__.ignore_breakpoints ! {\r\n        :(debug.pause)\r\n    } ?\r\n}:bp;\r\n\r\n\r\n.# Hold operator (same as `)\r\n.# 1 `+ 1\r\n.# 1 (1 hold)+ 1\r\n.# ``+ 1 1\r\n.# (2 hold)+ 1 1\r\n{__hold_n, {__hold_f : __hold_n^, {:__hold_f^, {~} O ~ __hold_f} __hold_n :` } 0 :` }:hold;\r\n\r\n.# ----\r\n.# LOAD\r\n.# ----\r\n\r\n.#? load S\\n  Load a script\r\n{{~\".aya\"+:F} 0 :`}:load;\r\n\r\n\r\n.# -------\r\n.# EXAMPLE\r\n.# -------\r\n\r\n{name,\r\n    [:(sys.ad) :9s \"examples\" :9s name \".aya\"] W :F\r\n}:example;\r\n\r\n\r\n\r\n.# -------\r\n.# OPT_MOD\r\n.# -------\r\n\r\n.{\r\n    Macro for creating a macro which runs a different block\r\n    depending on whether or not a module is present as an argument\r\n\r\n    .# Example:\r\n\r\n    opt_mod (\r\n        {block name mod,\r\n            \"with_mod!\" :P [block.` name mod]\r\n        }\r\n\r\n        {block name,\r\n            \"no mod!\":P [block.` name]\r\n        }\r\n    )\r\n\r\n    aya> f :{} ::foo {\"a\"}\r\n    with_mod!\r\n    [ {\"a\"} ::foo :{} ]\r\n\r\n    aya> f ::foo {\"a\"}\r\n    no mod!\r\n    [ {\"a\"} ::foo ]\r\n.}\r\n\r\n{with_mod no_mod,\r\n\r\n    {:with_mod no_mod,\r\n\r\n        .# Use constant substitution until var^ syntax is introduced\r\n        _with_mod:with_mod;\r\n        _no_mod:no_mod;\r\n\r\n        .# Store functions on stack so they can be retrieved later\r\n        :{\r\n            no_mod.` :no_mod\r\n            with_mod.` :with_mod\r\n        }\r\n\r\n        (3 hold)(\r\n            .# Variable argument prefix operator\r\n            .# aya> {mod name block, mod ::_fn =! {;} ? [mod name block.`]} :f\r\n\r\n            .# Jump ahead 3 items\r\n            .# aya> (```(\\:&:T ::sym=! {\\`}{\\}.? f) ::_fn)   :{} ::foo {+}\r\n            .# [ :{} ::foo {+} ]\r\n\r\n            .# Jump ahead 2 items\r\n            .# aya> (```(\\:&:T ::sym=! {\\`}{\\}.? f) ::_fn)   ::foo {+}\r\n            .# [ ::_fn ::foo {+} ]\r\n\r\n            \\:&:T ::sym=! {\\(1 hold)}{\\}.?\r\n\r\n\r\n            ( {mod name obj : is_module with_mod no_mod,\r\n\r\n                .# True if this function is being defined in a module\r\n                .# fn foo::bar {...}\r\n                .# False if defined in outer scope\r\n                .# fn ::bar {...}\r\n                mod ::_opt_mod =! :is_module;\r\n\r\n                .# If a module was provided, remove the ::_opt_mod symbol from the stack\r\n                is_module {;} ?\r\n\r\n                W .# Capture with_mod and no_mod from outer dict\r\n\r\n                .# Quote obj in case it is a block\r\n                is_module {\r\n                    obj.` name mod with_mod\r\n                } {\r\n                    obj.` name no_mod\r\n                }\r\n                .?\r\n            } )\r\n\r\n        )\r\n        ::_opt_mod\r\n    }\r\n\r\n    .# Use constant substitution until var^ syntax is introduced\r\n    :{ no_mod.`:_no_mod with_mod.`:_with_mod} .+\r\n\r\n} __aya__.:opt_mod;\r\n\r\n\r\n.# -----\r\n.#  DEF\r\n.# -----\r\n\r\n\r\n.{\r\n    `def` macro\r\n    Universal verbose syntax for defining functions\r\n\r\n    Define a function in the current scope:\r\n\r\n        aya> def ::double {2*}\r\n        aya> 3 double\r\n        6\r\n\r\n    Define a function in a module scope:\r\n\r\n        aya> :{}:math;\r\n        aya> def math::sq {2^}\r\n        aya> 5 math.sq\r\n        25\r\n\r\n    Define a function in a class/struct scope:\r\n\r\n        aya> struct point {x y}\r\n        aya> def point::sum {self, self.x self.y +}\r\n        aya> 2 3 point! :p\r\n        ( 2 3 ) point!\r\n        aya> p.sum\r\n        5\r\n\r\n    Define a function in a submodule:\r\n\r\n        aya> :{ :{}:stats; }:math;\r\n        aya> def (math.stats)::mean {.E\\W\\/}\r\n        aya> [1 2 3 4] math.stats.mean\r\n        2.5\r\n.}\r\n\r\n(\r\n    {block name mod,\r\n        block.` name mod :D ;\r\n    }\r\n    {block name,\r\n        block.` name := ;\r\n    }\r\n) __aya__.opt_mod :def;\r\n\r\n\r\n.# ----------------\r\n.#  CLASS / STRUCT\r\n.# ----------------\r\n\r\n\r\n.#\r\n.# `objcet`: Base object for class and struct\r\n.#\r\n:{\r\n    {meta : instance,\r\n        :{\r\n            meta :__meta__;\r\n            1 :__pushself__;\r\n        } :instance;\r\n\r\n        .# If it has a constructor call it\r\n        instance ::__init__ H {\r\n            instance.__init__\r\n        } ?\r\n\r\n        .# return the new object\r\n        instance\r\n    }:__new__;\r\n\r\n\r\n    {self,\r\n        \"($(self.__type__:C) 0x$(self M# 10 16 .&))\"\r\n    }:__repr__;\r\n\r\n    ::object:__type__;\r\n    0 :__pushself__;\r\n\r\n} __aya__.:object;\r\n\r\n\r\n.#\r\n.# `extend`: Keyword for extending a class\r\n.#\r\n\r\n{type::sym super,\r\n    :{\r\n        super:__meta__;\r\n        type:__type__;\r\n        .# copy new from super directly\r\n        super.__new__.` :__new__;\r\n        0:__pushself__;\r\n    } type :=\r\n} __aya__.:extend;\r\n\r\n__aya__.extend.` :extend;\r\n\r\n\r\n.#\r\n.# `class`: Macro keyword for creating a default class that extends `object`\r\n.#\r\n\r\n{: extend^ object(__aya__.object),\r\n    {:extend^ object^, ~:S~ object extend;} 1 :`\r\n}:class;\r\n\r\n\r\n.#\r\n.# `super`: Macro keyword for accessing super variables\r\n.#\r\n\r\n{{\r\n    ~:S~\r\n    \\:&.__meta__.__meta__@ :I\\; ~\r\n} 1 :` }:super;\r\n\r\n\r\n.#\r\n.# `struct`: Macro keyword for creating dataclasses\r\n.#\r\n\r\n{type__::sym members__::list super__ :\r\n    extend__(extend.`)\r\n    cls__,\r\n\r\n    type__ super__ extend__ : cls__;\r\n\r\n    .# __init__\r\n    {self,\r\n        .# grab all members from the stack\r\n        num_members :A\r\n        .# and assign them to self\r\n        members {self :D} .&;\r\n    } :{\r\n        members__ E :num_members;\r\n        members__   :members;\r\n    } .+ cls__.:__init__;\r\n\r\n    .# __str__/__repr__\r\n    .# default string:\r\n    .# ( m1 m2 ... mN ) type!\r\n    {self,\r\n        \"( \"\r\n        members :# {self \\:I \\;} \" \" % +\r\n        \" ) \" +\r\n        name  +\r\n        \"!\"+\r\n    } :{\r\n        type__ :C   :name;\r\n        members__ :members;\r\n    } .+ cls__.:__str__;\r\n\r\n    cls__.__str__.` cls__.:__repr__;\r\n\r\n    cls__\r\n} __aya__.:_struct_impl;\r\n\r\n{ : _struct_impl(__aya__._struct_impl.`) object(__aya__.object),\r\n    { : _struct_impl^ , :&.[0]:S~ \\.[1]~.*:#{:S~} object _struct_impl } 2 :`\r\n}:struct;\r\n\r\n\r\n.###########\r\n.# CONTROL #\r\n.###########\r\n\r\n\r\n.#? if (B) E E\\n  if statement:\\n  if (bool value) {\\n    then\\n  } {\\n    else\\n  }\r\n{(3 hold).?}:if;\r\n\r\n\r\n.#? dowhile E E\\n  evaluates E1 as long as E2 is true\\n  always evaluates at least once\r\n{(2 hold)({condition__ loop__,\r\n    {loop__ condition__} W\r\n})}:dowhile;\r\n\r\n\r\n.#? while E E\\n  evaluates E1 as long as E2 is true\r\n{(2 hold)({condition__ loop__,\r\n    condition__ {\r\n        {loop__ condition__} W\r\n    } ?\r\n})}:while;\r\n\r\n.#? A print\\n  convert to string a print to console\r\n{.P}:print;\r\n\r\n\r\n.#? A println\\n  convert to string and print to console on its own line\r\n{:P}:println;\r\n\r\n\r\n.{ Example:\r\n    aya> with {\"foo\" file.dummyfile!} ::f {\"File name is $(f.name)\" :P}\r\n    opened dummy file 'foo'\r\n    File name is foo\r\n    closed dummy file 'foo'\r\n    aya> with {\"foo\" file.dummyfile!} ::f {\"File name is $(f.name)\" :P \"Some error!\".D }\r\n    opened dummy file 'foo'\r\n    File name is foo\r\n    closed dummy file 'foo'\r\n    Some error!\r\n    stack:\r\n\r\n    just before:\r\n            {::f .Z .close} ~\r\n.}\r\n{(3 hold)(__aya__.with_ ~)}:with;\r\n\r\n\r\n.#? ::any ::sym isa\\n  returns true if the item's type matches the input\r\n{item::any type::sym,\r\n   type ::any = {\r\n       1\r\n   } {\r\n       item type :@\r\n   } .?\r\n}:isa;\r\n\r\n\r\n.# Helper function for `with` keyword which generates wrapper code\r\n.{\r\n    with {\"foo.txt\" file!} ::f {\r\n      f.lines #:P\r\n    }\r\n{init::block var::sym code::block: try catch close,\r\n    {init~ var := ; code~}.use[::init ::code ::var] :try ;\r\n    {var.Z .close .D}.use[::var] :catch ;\r\n    {var.Z .close}.use[::var] :close ;\r\n    {try catch .K close~}.use[::try ::catch ::close]\r\n    .setlocals[var]\r\n}__aya__.:with_;\r\n.}\r\n\r\n.# val local:foo\r\n{{\r\n    .[0]:S.[0] .# extract symbol\r\n    \\:&@  .# duplicate the value so we can leave it on the stack\r\n    :G.[-1] .# get local scope\r\n    :D; .# assign\r\n    .# val is left on the stack\r\n}1:`} :local;\r\n\r\n.################\r\n.# import types #\r\n.################\r\n\r\n[\r\n    \"test\"\r\n    .# Type extensions\r\n    \"num\"\r\n    \"char\"\r\n    \"list\"\r\n    \"str\"\r\n    \"block\"\r\n    \"sym\"\r\n\r\n    .# required libraries\r\n    \"importlib\"\r\n\r\n    .# Interpreter commands\r\n    \"interpreter\"\r\n\r\n] :# {f,\r\n    .# \"Loading base/$f...\" :P\r\n    load ([:(sys.ad) :9s \"base/$f\"]W)\r\n};\r\n","std/socket.aya":".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# socket.aya\n.# Defines socket and socket_server types\n\nstruct socket {\n    _sock\n}\n\nstruct socket_server {\n    _srv\n}\n\ndef socket_server::accept {self : socket^,\n    self._srv :(socket.accept) socket!\n}\n\ndef socket_server::listen {addr port : socket_server^,\n    addr port :(socket.open_server) socket_server!\n}\n\ndef socket_server::close {self,\n    self._srv :(socket.close)\n}\n\ndef socket_server::port {self,\n    self._srv :(socket.get_port)\n}\n\ndef socket_server::addr {self,\n    self._srv :(socket.get_addr)\n}\n\ndef socket::connect {addr port : socket^,\n    addr port :(socket.open_client) socket!\n}\n\ndef socket::recv {self,\n    self._sock :(socket.recv)\n}\n\ndef socket::port {self,\n    self._sock :(socket.get_port)\n}\n\ndef socket::addr {self,\n    self._sock :(socket.get_addr)\n}\n\ndef socket::send {self,\n    self._sock :(socket.send)\n}\n\ndef socket::println {data self,\n    data P \"\\r\\n\" + self._sock :(socket.send)\n}\n\ndef socket::close {self,\n    self._sock :(socket.close)\n}\n","std/canvas.aya":"require color {colors}\nrequire image {image}\n\nclass canvas\n\ndef canvas::__init__ {params::dict self : colors^,\n\n    .# Default values\n    :{\n        400 :width\n        400 :height\n        \"Canvas\" :name\n        0 :autoflush\n        0 :show\n        colors.white :bg\n        colors.black :fg\n        params W\n    }:params;\n\n    params.width self.:width;\n    params.height self.:height;\n\n    .# Input\n    [-1 -1] self.:_last_mouse_pos;\n\n    .# ::new params 0 :(graphics.MG) self.:id ;\n    params :(graphics.new) self.:id ;\n}\n\ndef canvas::__str__ {self,\n    \"<canvas($(self.id))>\"\n}\n\n(canvas.__str__.`,0); canvas.:__repr__;\n\ndef canvas::delay {self,\n    self._delay_ms 0 > {self._delay_ms$:P :Z} ?\n}\n\ndef canvas::line {xa ya xb yb self,\n    .# ::line :{ xa:xa ya:ya xb:xb yb:yb } self.id :(graphics.MG) ;\n    xa ya xb yb self.id :(graphics.line)\n}\n\ndef canvas::path {xs::list ys::list fill::num self,\n    xs ys fill self.id :(graphics.path)\n}\n\ndef canvas::point {x y self,\n    .#::line :{ x:xa:xb y:ya:yb} self.id :(graphics.MG) ;\n    x y x y self.id :(graphics.line)\n}\n\ndef canvas::circle {x y r self,\n    x y r2* $ 0 self.id :(graphics.ellipse)\n}\n\ndef canvas::fillcircle {x y r self,\n    x y r2* $ 1 self.id :(graphics.ellipse)\n}\n\ndef canvas::points {points r self,\n    points r2* $ self.id :(graphics.points)\n}\n\ndef canvas::set_color {color::color self,\n    .# ::set_color :{ color.r:r color.g:g color.b:b } self.id :(graphics.MG) ;\n    color.r color.g color.b self.id :(graphics.set_color)\n}\n\ndef canvas::set_alpha {a self,\n    .# ::set_alpha :{ a:a } self.id :(graphics.MG) ;\n    a self.id :(graphics.set_alpha)\n}\n\ndef canvas::set_stroke_width {n::num self,\n    n self.id :(graphics.set_stroke_width)\n}\n\ndef canvas::cap :{}\n\"butt\"   canvas.cap.:butt;\n\"round\"  canvas.cap.:round;\n\"square\" canvas.cap.:square;\n\ndef canvas::join :{}\n\"bevel\" canvas.join.:bevel;\n\"miter\" canvas.join.:miter;\n\"round\" canvas.join.:round;\n\ndef canvas::set_stroke {width::num cap::str join::str self,\n    width cap join self.id :(graphics.set_stroke)\n}\n\ndef canvas::set_grad {start::list ca::color end::list cb::color cycle::num self,\n    start.[0] start.[1] end.[0] end.[1]\n    ca.r ca.g ca.b ca.a 255*\n    cb.r cb.g cb.b cb.a 255*\n    cycle self.id :(graphics.set_paint_grad)\n}\n\ndef canvas::set_bg {color self,\n    .# ::set_bg :{ color.r:r color.g:g color.b:b } self.id :(graphics.MG) ;\n    color.r color.g color.b self.id :(graphics.set_bgcolor)\n}\n\ndef canvas::save {filename self,\n    .# Convert to string (in case it is a path object)\n    filename P\n    .# Add file extension if it does not exist\n    \".png\" filename.in ! {\".png\"+} ?\n\n    self.id :(graphics.save)\n}\n\ndef canvas::close {self,\n    .# ::close :{} self.id :(graphics.MG) ;\n    self.id :(graphics.close)\n}\n\ndef canvas::show {self,\n    self.id :(graphics.show)\n}\n\ndef canvas::isopen {self,\n    self.id :(graphics.isopen)\n}\n\ndef canvas::rect {x y w h self,\n    .# ::rect :{ x:x y:y w:w h:h } self.id :(graphics.MG) ;\n    x y w h 0 self.id :(graphics.rect)\n}\n\ndef canvas::fillrect {x y w h self,\n    .# ::rect :{ x:x y:y w:w h:h 1:fill} self.id :(graphics.MG) ;\n    x y w h 1 self.id :(graphics.rect)\n}\n\ndef canvas::clear {self,\n    self.id :(graphics.clear)\n}\n\ndef canvas::viewmat {data self,\n    data self.id :(graphics.viewmat)\n}\n\n.# Block until the canvas is closed\ndef canvas::wait {self,\n    { 100:Z self.isopen } W\n}\n\ndef canvas::move_events {self,\n    self.id :(graphics.move_events)\n}\n\n.# Get the most recent mouse x/y\n.# return [-1 -1] if no updates\ndef canvas::mouse_pos {self : move,\n    self.move_events :move;\n    move E 0 > {\n        [move.[-1] :&.x\\.y] self.:_last_mouse_pos;\n    } ?\n    self._last_mouse_pos\n}\n\ndef canvas::pressed_buttons {self,\n    self.id :(graphics.pressed_buttons)\n}\n\ndef canvas::typed_chars {self,\n    self.id :(graphics.typed_chars)\n}\n\ndef canvas::pressed_keys {self,\n    self.id :(graphics.pressed_keys)\n}\n\ndef canvas::text {self,\n    self.id :(graphics.text)\n}\n\ndef canvas::get_pixels {self : data image^,\n    self.id :(graphics.get_pixels) :data;\n    data.r data.g data.b data.a data.width data.height data.meta image!\n}\n","std/viewmat.aya":"require canvas {canvas}\n\ndef ::draw_scaled { data scale : cvs canvas^,\n    .# special case for matrix\n    data :T ::matrix = {data.rows :data;} ?\n\n    :{\n        data E :height;\n        data.[0] E :width;\n        scale :scale;\n        \"viewmat\" :name;\n    } canvas! :cvs;\n\n    data cvs.viewmat\n\n    cvs\n}\n\ndef ::draw { data : width height scale size draw_scaled^,\n    .# special case for matrix\n    data :T ::matrix = {data.rows :data;} ?\n\n    data E :height;\n    data.[0] E :width;\n    width height .< :size;\n\n    .# Set a reasonable scale\n    1 :scale;\n    size 400 :< { 2:scale; } ?\n    size 100 :< { 8:scale; } ?\n    size 40  :< { 16:scale; } ?\n    size 10  :< { 64:scale; } ?\n\n    data scale draw_scaled\n}\n\n.# immediately open the canvas\ndef ::show {: draw^,\n    draw.show\n}\n","std/plot.aya":"class plot\nclass multiplot\nclass dataset\n\n.# If true, the view command will not open windows\n.# Generally useful is running tests\ndef plot::_supress_windows 0\n\n.# plot\n.#   data::list : list of plot.dataset objects (see plot.dataset)\n.#   title::str : plot title\n.#   bgcolor::color/str : background color\n.#   color_cycle::list : override the default color cycle\n.#   x,y::dict : axis configuration\n.#       gridlines::bool : show axis gridlines\n.#       gridline_color::color/str : axis gridline color\n.#       zeroline::bool : show axis zero line\n.#       visible::bool : draw axis labels\n.#       lim::list : min and max axis limits\n.#       label::str : axis label\n.#   <any value in dataset params will be used as the default value>\n.#       for example, setting stroke to 10 here will make it the default\n.#       for all lines that do not explicitly provide one\ndef plot::__init__ {self,\n    [] self.:data;\n\n    :{} self.:y;\n    :{} self.:x;\n}\n\n\n.# plot.dataset\n.#   x::list : domain data\n.#   y::list : range data\n.#   label::str : name of the dataset\n.#   color::color/str : color of line/shapes\n.#   stroke::num : stroke weight (may be non-integer)\n.#   lines::num (bool) : draw lines between points\n.#   points::num (bool) : draw points\n.#   yclip::list ([min,max]) : y values outside of this range will not\n.#       be rendered, they will create a jump in the graph\ndef dataset::__init__ {x y params self,\n    x self.:x;\n    y self.:y;\n    self params .+ ;\n}\n\n.# Get y as a list\n.# If y is a block, apply it to x and return a list\ndef plot::_get_y {x::list y plot,\n    {\n        (y.` :T ::block =) {\n            x y :y;\n        } (y.` :T ::list =) {\n            .# noop\n        } {\n            \"invalid\" .D\n        }\n    } :?\n    y\n}\n\n.# Add a dataset to the plot\ndef plot::_add_dataset {d::dataset self,\n    d self.data .B ;\n}\n\n.# Generic plot function\n.# Add a new dataset to the plot\ndef plot::plot {x::list y params::dict self : dataset^,\n    x (x y.` self.M._get_y) params dataset! self._add_dataset\n}\n\n.# Adds a new dataset to the plot, formatted as a scatter plot\ndef plot::scatter {x::list y params::dict self : dataset^ d,\n    x (x y.` self.M._get_y) params dataset! :d;\n    0 d.:lines;\n    1 d.:points;\n    d self._add_dataset\n}\n\n.# Show the plot in a window\ndef plot::view {self,\n    self.M._supress_windows ! {\n        \"\" self.:filename;\n        self :(plot.plot)\n    } ?\n\n}\n\n.# Multi-Plot\n.##############\n\ndef multiplot::__init__ {self,\n    [] self.:subplots;\n\n    :{} self.:y;\n    :{} self.:x;\n}\n\ndef multiplot::add {plot self,\n    plot self.subplots.append;\n}\n\ndef multiplot::view {self : plot^,\n    plot._supress_windows ! {\n        \"\" self.:filename;\n        self :(plot.multiplot)\n    } ?\n}\n\n\n.# Quick Plot Functions\n.########################\n\n.# Create a line plot with default paramaters and x,y as a dataset\ndef ::line {x::list y::list : p plot^,\n    plot! :p;\n    x y :{} p.plot\n    0 p.:legend;\n    p\n}\n\n.# Create a line plot with default paramaters and x,y as a dataset\ndef ::fns {fns::list a::num b::num : x p plot^,\n    plot! :p;\n    [a b 300] .R :x;\n    fns {f, \n        x :& f.` O :{ f.`P:label} p.plot\n    } O;\n    1 p.:legend;\n    p\n}\n","base/sym.aya":".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metatable definition for the built-in `sym` type\n\n:{\n    .{? ::sym .op\n\n        Return a block containing the operator\n        Does not currently work with quoted operators (TODO: fix internal representation)\n\n        aya> ::+ .op\n        {+}\n        aya> ::Ms .op\n        {Ms}\n        aya> ::\"Ms\" .op\n        Error\n    .}\n    {sym, \n        ::ops Ma\n        .# filter out items where the symbol doesn't match\n        :# {k v, v.overload sym H {v}?}\n        .# Grab the `call` block\n        :V.[0].call.`\n    }:op;\n\n    .# Get a dict of all operator/symbol pairs\n    :{\n        \"overloadable\" M? :# {\n            .# Get <name> <op> as strings\n            :& \"overloadable:.*$\" & .[0] \" \" S .[-1] \\ \" \" S .[0]\n            .# Lambda to apply to each <name> <op>\n            ({name op,\n                .# If the name is \"__add__/__radd__\", only use the first one\n                name '/ S .[0]:name;\n                .# Attempt to parse the op ( operator __each__ \":#\" will fail)\n                .# And assign the op to its name\n                {op.~ name :=} {;} .K\n            })\n        }\n    }:_overloads;\n\n    {s, {::_.M._overloads s I} {; s :C.~ } .K }:op;\n\n\n    .{? ::sym .rev\n\n        Return the reverse overload for a symbol\n        - If the symbol is an operator and has a reverse overload, return it\n        - If the symbol is an operator but does not have a reverse overload,\n            return the original operator\n        - If the symbol is not an operator, throw an error\n\n        aya> ::+ .rev\n        ::__radd__\n    .}\n\n    :{\n        .# Get the overload list for all ops\n        ::ops Ma :#{.overload}\n        .# Get all ops with non-zero length overloads\n        .[{E 0 = !}]\n        .# For each overload list\n        :V :#{l,\n            .# Assign the reversed op to the standard one\n            .# If the list length is 1, standard will be assigned to itself\n            l.[-1] l.[0] :=\n        }\n    }:_rev_overloads;\n\n    { ::_.M._rev_overloads \\ I }:rev;\n\n}\n.# Merge with sym metatable\n::_ .M \\.+\n","std/time.aya":"class rate\n\ndef rate::__init__ {hz self,\n    hz self.:hz;\n    1 hz / 1000 * self.:sleep_duration_ms;\n    M$ self.:last_sleep_time;\n}\n\ndef rate::sleep {self : time_since_last_sleep,\n    M$ self.last_sleep_time - :time_since_last_sleep;\n\n    self.sleep_duration_ms time_since_last_sleep -\n    .# floor and clip to 0\n    .\\ 0 .<\n    .# sleep\n    :Z\n\n    M$ self.:last_sleep_time;\n}\n"};